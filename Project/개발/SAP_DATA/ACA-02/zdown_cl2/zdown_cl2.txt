*&---------------------------------------------------------------------*
*& Report ZDOWN_CL2
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zdown_cl2.
*======================================================================================================================
*  Mass download version 1.4.6.
*----------------------------------------------------------------------------------------------------------------------
*  PROGRAM DESCRIPTION & USE
*  Allows a user to download programs, Functions, DD definitions, etc to the presentation server.  This version searches
*  recursively for nested includes and function modules, and allows you to download the resulting code as standard text
*  or HTML web pages within a suitable directory structure.
*
*  You can either search by object name, using wildcards if you wish, or a combination of Author and object name.  If
*  you want all objects returned for a particular author then select the author name and choose the most suitable
*  radiobutton.  All objects will be returned if the fields to the right hand side of the radiobutton are left completely
*  blank.
*
*  Compatible with R/3 Enterprise and Netweaver, for older versions of SAP you will need Direct Download version 5.xx.
*  This version removes the programming limitations imposed by developing across SAP releases 3 to 4.6.
*
*  In order to be able to download files to the SAP server you must first set up a logical filepath within transaction
*  'FILE', or use an existing one.  You must also create a external operating system command in SM69 called ZDTX_MKDIR. This
*  will then be used to create any directories needed on the SAP server

*  This program is intended to allow a person to keep a visual representation of a program for backup purposes only as
*  has not been designed to allow programs to be uploaded to SAP systems.
*----------------------------------------------------------------------------------------------------------------------
*
* Author          : Copyright (C) 1998 E.G.Mellodew
* program contact : www.dalestech.com

* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*
*----------------------------------------------------------------------------------------------------------------------

*----------------------------------------------------------------------------------------------------------------------
*  SAP Tables
*----------------------------------------------------------------------------------------------------------------------
TABLES: trdir, seoclass, tfdir, enlfdir, dd02l, tadiv.
TYPE-POOLS: abap, seor.

*----------------------------------------------------------------------------------------------------------------------
*  Types
*----------------------------------------------------------------------------------------------------------------------
* text element structure
TYPES: tTextTable LIKE textpool.
* GUI titles
TYPES: tGUITitle LIKE d347t.

* Message classes
TYPES: BEGIN OF tMessage,
         arbgb LIKE t100-arbgb,
         stext LIKE t100a-stext,
         msgnr LIKE t100-msgnr,
         text  LIKE t100-text,
       END OF tMessage.

* Screen flow.
TYPES: BEGIN OF tScreenFlow,
         screen LIKE d020s-dnum,
         code   LIKE d022s-line,
       END OF tScreenFlow.

* Holds a table\structure definition
TYPES: BEGIN OF tDictTableStructure,
         fieldname LIKE dd03l-fieldname,
         position  LIKE dd03l-position,
         keyflag   LIKE dd03l-keyflag,
         rollname  LIKE dd03l-rollname,
         domname   LIKE dd03l-domname,
         datatype  LIKE dd03l-datatype,
         leng      LIKE dd03l-leng,
         lowercase TYPE lowercase,
         ddtext    LIKE dd04t-ddtext,
       END OF tdictTableStructure.

* Holds a tables attributes + its definition
TYPES: BEGIN OF tDictTable,
         tablename  LIKE dd03l-tabname,
         tableTitle LIKE dd02t-ddtext,
         iStructure TYPE tDictTableStructure OCCURS 0,
       END OF tDictTable.

TYPES: BEGIN OF tDictFilename,
         tablename LIKE dd03l-tabname,
         filename  TYPE string,
       END OF tDictFilename.

* Include program names
TYPES: BEGIN OF tInclude,
         includeName  LIKE trdir-name,
         includeTitle LIKE tftit-stext,
       END OF tInclude.

* Exception class texts
TYPES: BEGIN OF tConcept,
         constName TYPE string,
         concept   TYPE sotr_conc,
       END OF tConcept.

* Method
TYPES: BEGIN OF tMethod,
         cmpName(61),
         descript    LIKE vseomethod-descript,
         exposure    LIKE vseomethod-exposure,
         methodKey   TYPE string,
       END OF tMethod.

* Interfaces
TYPES: BEGIN OF tInterface,
         interfaceName LIKE vseoclass-clsname,
       END OF tInterface.

* Class
TYPES: BEGIN OF tClass,
         scanned(1),
         clsname           LIKE vseoclass-clsname,
         descript          LIKE vseoclass-descript,
         msg_id            LIKE vseoclass-msg_id,
         exposure          LIKE vseoclass-exposure,
         state             LIKE vseoclass-state,
         clsfinal          LIKE vseoclass-clsfinal,
         r3release         LIKE vseoclass-r3release,
         iMethods          TYPE tMethod OCCURS 0,
         iDictStruct       TYPE tDictTable OCCURS 0,
         iTextElements     TYPE tTextTable OCCURS 0,
         iMessages         TYPE tMessage OCCURS 0,
         iInterfaces       TYPE tInterface OCCURS 0,
         iConcepts         TYPE tConcept OCCURS 0,
         textElementKey    TYPE string,
         publicClassKey    TYPE string,
         privateClassKey   TYPE string,
         protectedClassKey TYPE string,
         typesClassKey     TYPE string,
         exceptionClass    TYPE abap_bool,
       END OF tClass.

* function modules
TYPES: BEGIN OF tFunction,
         functionName        LIKE tfdir-funcName,
         functionGroup       LIKE enlfdir-area,
         includeNumber       LIKE tfdir-include,
         functionMainInclude LIKE tfdir-funcName,
         functionTitle       LIKE tftit-stext,
         topIncludeName      LIKE tfdir-funcName,
         progname            LIKE tfdir-pname,
         programLinkName     LIKE tfdir-pname,
         messageClass        LIKE t100-arbgb,
         iTextElements       TYPE tTextTable OCCURS 0,
         iSelectiontexts     TYPE tTextTable OCCURS 0,
         iMessages           TYPE tMessage OCCURS 0,
         iIncludes           TYPE tInclude OCCURS 0,
         iDictStruct         TYPE tDictTable OCCURS 0,
         iGUITitle           TYPE tGUITitle OCCURS 0,
         iScreenFlow         TYPE tScreenFlow OCCURS 0,
       END OF tFunction.

TYPES: BEGIN OF tProgram,
         progname        LIKE trdir-name,
         programTitle    LIKE tftit-stext,
         subc            LIKE trdir-subc,
         messageClass    LIKE t100-arbgb,
         iMessages       TYPE tMessage OCCURS 0,
         iTextElements   TYPE tTextTable OCCURS 0,
         iSelectiontexts TYPE tTextTable OCCURS 0,
         iGUITitle       TYPE tGUITitle OCCURS 0,
         iScreenFlow     TYPE tScreenFlow OCCURS 0,
         iIncludes       TYPE tInclude OCCURS 0,
         iDictStruct     TYPE tDictTable OCCURS 0,
       END OF tProgram.

*----------------------------------------------------------------------------------------------------------------------
*  Internal tables
*----------------------------------------------------------------------------------------------------------------------
*  Dictionary object
DATA: iDictionary TYPE STANDARD TABLE OF tDictTable WITH HEADER LINE.
*  Dictionary objects which have previously been downloaded
DATA: iDictFilename TYPE STANDARD TABLE OF tDictFilename WITH HEADER LINE.
* Function modules.
DATA: iFunctions TYPE STANDARD TABLE OF tFunction WITH HEADER LINE.
* Function modules used within programs.
DATA: iProgFunctions TYPE STANDARD TABLE OF tFunction WITH HEADER LINE.
* Tree display structure.
DATA: iTreeDisplay TYPE STANDARD TABLE OF snodetext WITH HEADER LINE.
* Message class data
DATA: iMessages TYPE STANDARD TABLE OF tMessage WITH HEADER LINE.
* Holds a single message class an all of its messages
DATA: iSingleMessageClass TYPE STANDARD TABLE OF tMessage WITH HEADER LINE.
* Holds program related data
DATA: iPrograms TYPE STANDARD TABLE OF tProgram WITH HEADER LINE.
* Classes
DATA: iClasses TYPE STANDARD TABLE OF tClass WITH HEADER LINE.
* Table of paths created on the SAP server
DATA: iServerPaths TYPE STANDARD TABLE OF string WITH HEADER LINE.

*----------------------------------------------------------------------------------------------------------------------
*  Table prototypes
*----------------------------------------------------------------------------------------------------------------------
DATA: dumiDictStructure TYPE STANDARD TABLE OF tDictTableStructure.
DATA: dumiTextTab TYPE STANDARD TABLE OF tTextTable.
DATA: dumiIncludes TYPE STANDARD TABLE OF tInclude.
DATA: dumiHtml TYPE STANDARD TABLE OF string.
DATA: dumiHeader TYPE STANDARD TABLE OF string .
DATA: dumiScreen TYPE STANDARD TABLE OF tScreenFlow .
DATA: dumIGUITitle TYPE STANDARD TABLE OF tGUITitle.
DATA: dumiMethods TYPE STANDARD TABLE OF tMethod.
DATA: dumiConcepts TYPE STANDARD TABLE OF tConcept.
DATA: dumiInterfaces TYPE STANDARD TABLE OF tInterface.

*----------------------------------------------------------------------------------------------------------------------
*   Global objects
*----------------------------------------------------------------------------------------------------------------------
DATA: objFile TYPE REF TO cl_gui_frontend_services.
DATA: objRuntimeError TYPE REF TO cx_root.

*----------------------------------------------------------------------------------------------------------------------
*  Constants
*----------------------------------------------------------------------------------------------------------------------
CONSTANTS: versionno TYPE string VALUE '1.4.6'.
CONSTANTS: tables TYPE string VALUE 'TABLES'.
CONSTANTS: table TYPE string VALUE 'TABLE'.
CONSTANTS: like TYPE string VALUE 'LIKE'.
CONSTANTS: type TYPE string VALUE 'TYPE'.
CONSTANTS: typerefto TYPE string VALUE 'TYPE REF TO'.
CONSTANTS: structure TYPE string VALUE 'STRUCTURE'.
CONSTANTS: lowstructure TYPE string VALUE 'structure'.
CONSTANTS: occurs TYPE string VALUE 'OCCURS'.
CONSTANTS: function TYPE string VALUE 'FUNCTION'.
CONSTANTS: callfunction TYPE string VALUE ' CALL FUNCTION'.
CONSTANTS: message TYPE string  VALUE 'MESSAGE'.
CONSTANTS: include TYPE string VALUE 'INCLUDE'.
CONSTANTS: lowinclude TYPE string VALUE 'include'.
CONSTANTS: destination TYPE string VALUE 'DESTINATION'.
CONSTANTS: is_table TYPE string VALUE 'T'.
CONSTANTS: is_program TYPE string VALUE 'P'.
CONSTANTS: is_screen TYPE string VALUE 'S'.
CONSTANTS: is_guititle TYPE string VALUE 'G'.
CONSTANTS: is_documentation TYPE string VALUE 'D'.
CONSTANTS: is_messageclass TYPE string VALUE 'MC'.
CONSTANTS: is_function TYPE string VALUE 'F'.
CONSTANTS: is_class TYPE string VALUE 'C'.
CONSTANTS: is_method TYPE string VALUE 'M'.
CONSTANTS: asterix TYPE string VALUE '*'.
CONSTANTS: comma TYPE string VALUE ','.
CONSTANTS: period TYPE string VALUE '.'.
CONSTANTS: dash TYPE string VALUE '-'.
CONSTANTS: true TYPE abap_bool VALUE 'X'.
CONSTANTS: false TYPE abap_bool VALUE ''.
CONSTANTS: lt TYPE string VALUE '&lt;'.
CONSTANTS: gt TYPE string VALUE '&gt;'.
CONSTANTS: unix TYPE string VALUE 'UNIX'.
CONSTANTS: non_unix TYPE string VALUE 'not UNIX'.
CONSTANTS: htmlextension TYPE string VALUE 'html'.
CONSTANTS: textextension TYPE string VALUE 'txt'.
CONSTANTS: ss_code TYPE c VALUE 'C'.
CONSTANTS: ss_table TYPE c VALUE 'T'.

*----------------------------------------------------------------------------------------------------------------------
*  Global variables
*----------------------------------------------------------------------------------------------------------------------
DATA: statusBarMessage(100).
DATA: forcedExit TYPE abap_bool VALUE false.
DATA: startTime LIKE sy-uzeit.
DATA: runTime LIKE sy-uzeit.
DATA: downloadFileExtension TYPE string.
DATA: downloadFolder TYPE string.
DATA: serverSlashSeparator TYPE string.
DATA: frontendSlashSeparator TYPE string.
DATA: slashSeparatorToUse TYPE string.
DATA: serverFilesystem TYPE filesys_d.
DATA: serverFolder TYPE string.
DATA: frontendOpSystem TYPE string.
DATA: serverOpSystem TYPE string.
DATA: customerNameSpace TYPE string.
RANGES: soProgramName FOR trdir-name.
RANGES: soAuthor FOR usr02-bname.
RANGES: soTableNames FOR dd02l-tabname.
RANGES: soFunctionName  FOR tfdir-funcName.
RANGES: soClassName FOR vseoclass-clsname.
RANGES: soFunctionGroup FOR enlfdir-area.
FIELD-SYMBOLS: <waDictStruct> TYPE tDictTable.

*----------------------------------------------------------------------------------------------------------------------
*  Selection screen declaration
*----------------------------------------------------------------------------------------------------------------------
* Author
SELECTION-SCREEN: BEGIN OF BLOCK b1 WITH FRAME TITLE tBlock1.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 5(23) tAuth.
    PARAMETERS: pAuth LIKE usr02-bname MEMORY ID mauth.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 5(36) tPmod.
    PARAMETERS: pMod AS CHECKBOX.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK b1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE tBlock2.
* Tables
  SELECTION-SCREEN BEGIN OF LINE.
    PARAMETERS: rTable RADIOBUTTON GROUP r1.
    SELECTION-SCREEN COMMENT 5(15) tRtable.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(15) tPtable.
    SELECT-OPTIONS: soTable FOR dd02l-tabname.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(79) tTnote.
  SELECTION-SCREEN END OF LINE.

* Message classes
  SELECTION-SCREEN BEGIN OF LINE.
    PARAMETERS: rMess RADIOBUTTON GROUP r1.
    SELECTION-SCREEN COMMENT 5(18) tPMes.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(18) tMname.
    PARAMETERS: pMname LIKE t100-arbgb MEMORY ID mmname.
  SELECTION-SCREEN END OF LINE.

* Function modules
  SELECTION-SCREEN BEGIN OF LINE.
    PARAMETERS: rFunc RADIOBUTTON GROUP r1.
    SELECTION-SCREEN COMMENT 5(30) tRfunc.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(15) tPfname.
    SELECT-OPTIONS: soFname FOR tfdir-funcName.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(15) tFgroup.
    SELECT-OPTIONS: soFgroup FOR enlfdir-area.
  SELECTION-SCREEN END OF LINE.

* Classes
  SELECTION-SCREEN BEGIN OF LINE.
    PARAMETERS: rClass RADIOBUTTON GROUP r1.
    SELECTION-SCREEN COMMENT 5(30) tRClass.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(15) tPcName.
    SELECT-OPTIONS: soClass FOR seoclass-clsname.
  SELECTION-SCREEN END OF LINE.

* Programs / includes
  SELECTION-SCREEN BEGIN OF LINE.
    PARAMETERS: rProg RADIOBUTTON GROUP r1 DEFAULT 'X'.
    SELECTION-SCREEN COMMENT 5(18) tProg.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 10(15) tRpname.
    SELECT-OPTIONS: soProg FOR trdir-name.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN SKIP.
* Language
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(27) tMLang.
    PARAMETERS: pMLang LIKE t100-sprsl DEFAULT 'EN'.
  SELECTION-SCREEN END OF LINE.

* Package
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(24) tPack.
    SELECT-OPTIONS: soPack FOR tadiv-devclass.
  SELECTION-SCREEN END OF LINE.

* Customer objects
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(27) tCust.
    PARAMETERS: pCust AS CHECKBOX DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.

* Alt customer name range
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(27) tNRange.
    PARAMETERS: pCName TYPE namespace MEMORY ID mnamespace.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK b2.

* Additional things to download.
SELECTION-SCREEN: BEGIN OF BLOCK b3 WITH FRAME TITLE tBlock3.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tPtext.
    PARAMETERS: pText AS CHECKBOX DEFAULT 'X' MEMORY ID mtext.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tMess.
    PARAMETERS: pMess AS CHECKBOX DEFAULT 'X' MEMORY ID mmess.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tPinc.
    PARAMETERS: pInc AS CHECKBOX DEFAULT 'X' MEMORY ID minc.
    SELECTION-SCREEN COMMENT 40(20) tReci.
    PARAMETERS: pReci AS CHECKBOX DEFAULT 'X' MEMORY ID mreci.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tPfunc.
    PARAMETERS: pFunc AS CHECKBOX DEFAULT 'X' MEMORY ID mfunc.
    SELECTION-SCREEN COMMENT 40(20) tRecf.
    PARAMETERS: pRecf AS CHECKBOX DEFAULT 'X' MEMORY ID mrecf.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tRecC.
    PARAMETERS: pRecC AS CHECKBOX DEFAULT 'X' MEMORY ID mrecc.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tFDoc.
    PARAMETERS: pFDoc AS CHECKBOX DEFAULT 'X' MEMORY ID mfdoc.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tCDoc.
    PARAMETERS: pCDoc AS CHECKBOX DEFAULT 'X' MEMORY ID mcdoc.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tPscr.
    PARAMETERS: pScr AS CHECKBOX DEFAULT 'X' MEMORY ID mscr.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tPdict.
    PARAMETERS: pDict AS CHECKBOX DEFAULT 'X' MEMORY ID mdict.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tSortT.
    PARAMETERS: pSortT AS CHECKBOX DEFAULT ' ' MEMORY ID msortt.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK b3.

* File details
SELECTION-SCREEN: BEGIN OF BLOCK b4 WITH FRAME TITLE tBlock4.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(20) tPhtml.
    PARAMETERS: pHtml RADIOBUTTON GROUP g1 DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 5(29) tBack.
    PARAMETERS: pBack AS CHECKBOX DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(20) tPtxt.
    PARAMETERS: pTxt RADIOBUTTON GROUP g1.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN SKIP.

* Download to SAP server
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(25) tServ.
    PARAMETERS: pServ RADIOBUTTON GROUP g2.
  SELECTION-SCREEN END OF LINE.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 8(20) tSPath.
    PARAMETERS: pLogical LIKE filename-fileintern MEMORY ID mlogical.
  SELECTION-SCREEN END OF LINE.
  SELECTION-SCREEN COMMENT /28(60) tSDPath.

* Download to PC
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(25) tPc.
    PARAMETERS: pPc RADIOBUTTON GROUP g2 DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 8(20) tPpath.
    PARAMETERS: pFolder LIKE rlgrap-filename MEMORY ID mfolder.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK b4.

* Display options
SELECTION-SCREEN: BEGIN OF BLOCK b5 WITH FRAME TITLE tBlock5.
* Display final report
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tRep.
    PARAMETERS: pRep AS CHECKBOX DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.
* Display progress messages
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(33) tProMess.
    PARAMETERS: pProMess AS CHECKBOX DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN: END OF BLOCK b5.

*----------------------------------------------------------------------------------------------------------------------
* Display a directory picker window
*----------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR pFolder.

  DATA: objFile TYPE REF TO cl_gui_frontend_services.
  DATA: pickedFolder TYPE string.
  DATA: initialFolder TYPE string.

  IF sy-batch IS INITIAL.
    CREATE OBJECT objFile.

    IF NOT pFolder IS INITIAL.
      initialFolder = pFolder.
    ELSE.
      objFile->get_temp_directory( CHANGING temp_dir = initialFolder
                                   EXCEPTIONS cntl_error = 1
                                             error_no_gui = 2
                                             not_supported_by_gui = 3 ).
    ENDIF.

    objFile->directory_browse( EXPORTING initial_folder = initialFolder
                               CHANGING selected_folder = pickedFolder
                               EXCEPTIONS cntl_error = 1
                                          error_no_gui = 2
                                          not_supported_by_gui = 3 ).

    IF sy-subrc = 0.
      pFolder = pickedFolder.
    ELSE.
      WRITE: / 'An error has occured picking a folder'.
    ENDIF.
  ENDIF.

*----------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN.
*----------------------------------------------------------------------------------------------------------------------
  CASE 'X'.
    WHEN pPc.
      IF pFolder IS INITIAL.
*       User must enter a path to save to
        MESSAGE e000(oo) WITH 'You must enter a file path'.
      ENDIF.

    WHEN pServ.
      IF pLogical IS INITIAL.
*       User must enter a logical path to save to
        MESSAGE e000(oo) WITH 'You must enter a logical file name'.
      ENDIF.
  ENDCASE.

*----------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON pLogical.
*----------------------------------------------------------------------------------------------------------------------
  IF NOT pServ IS INITIAL.
    CALL FUNCTION 'FILE_GET_NAME'
      EXPORTING
        logical_filename = pLogical
      IMPORTING
        file_name        = serverFolder
      EXCEPTIONS
        file_not_found   = 1
        OTHERS           = 2.
    IF sy-subrc = 0.
      IF serverFolder IS INITIAL.
        MESSAGE e000(oo) WITH 'No file path returned from logical filename'.
      ELSE.
*       Path to display on the selection screen
        tSDPath = serverFolder.
*       Remove the trailing slash off the path as the subroutine buildFilename will add an extra one
        SHIFT serverFolder RIGHT DELETING TRAILING serverSlashSeparator.
        SHIFT serverFolder LEFT DELETING LEADING space.
      ENDIF.
    ELSE.
      MESSAGE e000(oo) WITH 'Logical filename does not exist'.
    ENDIF.
  ENDIF.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soProg-low.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'PROG'
      object_name           = soProg-low
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soProg-low
    EXCEPTIONS
      cancel                = 1.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soProg-high.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'PROG'
      object_name           = soProg-high
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soProg-high
    EXCEPTIONS
      cancel                = 1.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soClass-low.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'F4_DD_ALLTYPES'
    EXPORTING
      object               = soClass-low
      suppress_selection   = 'X'
      display_only         = ''
      only_types_for_clifs = 'X'
    IMPORTING
      result               = soClass-low.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soClass-high.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'F4_DD_ALLTYPES'
    EXPORTING
      object               = soClass-high
      suppress_selection   = 'X'
      display_only         = ''
      only_types_for_clifs = 'X'
    IMPORTING
      result               = soClass-high.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soFName-low.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'FUNC'
      object_name           = soFname-low
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soFName-low
    EXCEPTIONS
      cancel                = 1.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soFName-high.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'FUNC'
      object_name           = soFname-high
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soFName-high
    EXCEPTIONS
      cancel                = 1.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soFGroup-low.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'FUGR'
      object_name           = soFGroup-low
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soFGroup-low
    EXCEPTIONS
      cancel                = 1.

* ---------------------------------------------------------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR soFGroup-high.
* ---------------------------------------------------------------------------------------------------------------------
  CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
    EXPORTING
      object_type           = 'FUGR'
      object_name           = soFGroup-high
      suppress_selection    = 'X'
      use_alv_grid          = ''
      without_personal_list = ''
    IMPORTING
      object_name_selected  = soFGroup-high
    EXCEPTIONS
      cancel                = 1.

*----------------------------------------------------------------------------------------------------------------------
* initialisation
*----------------------------------------------------------------------------------------------------------------------
INITIALIZATION.
* Parameter screen texts.
  tBlock1 = 'Author (Optional)'.
  tBlock2 = 'Objects to download'.
  tBlock3 = 'Additional downloads for programs, function modules and classes'.
  tBlock4 = 'Download parameters'.
  tBlock5 = 'Display options'.
  tAuth   = 'Author name'.
  tPmod   = 'Include programs modified by author'.
  tCust   = 'Only customer objects'.
  tNRange = 'Alt customer name range'.
  tRtable = 'Tables / Structures'.
  tPtable = 'Table name'.
  tTnote  = 'Note: tables are stored under the username of the last person who modified them'.
  tRfunc  = 'Function modules'.
  tPfname = 'Function name'.
  tFgroup = 'Function group'.
  tRClass  = 'Classes'.
  tPcname = 'Class name'.
  tMess   = 'Message class'.
  tMName  = 'Class name'.
  tMLang  = 'Language'.
  tProg   = 'Programs'.
  tRpname = 'Program name'.
  tPack   = 'Package'.
  tPtxt   = 'Text document'.
  tPhtml  = 'HTML document'.
  tBack   = 'Include background colour'.
  tPtext  = 'Text elements'.
  tPinc   = 'Include programs'.
  tRecI   = 'Recursive search'.
  tPpath  = 'File path'.
  tSPath  = 'Logical file name'.
  tPmes   = 'Message classes'.
  tPfunc  = 'Function modules'.
  tFDoc    = 'Function module documentation'.
  tCDoc    = 'Class documentation'.
  tRecf   = 'Recursive search'.
  tRecC   = 'Class recursive search'.
  tPscr   = 'Screens'.
  tPdict  = 'Dictionary structures'.
  tSortT  = 'Sort table fields alphabetically'.
  tServ   = 'Download to server'.
  tPc     = 'Download to PC'.
  tRep    = 'Display download report'.
  tProMess  = 'Display progress messages'.

* Determine the frontend operating system type.
  IF sy-batch IS INITIAL.
    PERFORM determineFrontendOPSystem USING frontendSlashSeparator frontendOpSystem.
  ENDIF.
  PERFORM determineServerOpsystem USING serverSlashSeparator serverFileSystem serverOpsystem.

* Determine if the external command exists.  If it doesn't then disable the server input field
  PERFORM findExternalCommand USING serverFileSystem.

*----------------------------------------------------------------------------------------------------------------------
START-OF-SELECTION.
*----------------------------------------------------------------------------------------------------------------------
  PERFORM checkComboBoxes.
  PERFORM fillSelectionRanges.
  startTime = sy-uzeit.

* Don't display status messages if we are running in the background
  IF NOT sy-batch IS INITIAL.
    pProMess = ''.
  ENDIF.

* Fool the HTML routines to stop them hyperlinking anything with a space in them
  IF pCName IS INITIAL.
    customerNameSpace  = '^'.
  ELSE.
    customerNameSpace = pCName.
  ENDIF.

* Set the file extension and output type of the file
  IF pTxt IS INITIAL.
    downloadFileExtension = htmlextension.
  ELSE.
    downloadFileExtension = textextension.
  ENDIF.

* Determine which operating slash and download directory to use
  CASE 'X'.
    WHEN pPc.
      slashSeparatorToUse = frontendSlashSeparator.
      downloadFolder = pFolder.
    WHEN pServ.
      slashSeparatorToUse = serverSlashSeparator.
      downloadFolder = serverFolder.
  ENDCASE.

* Main program flow.
  CASE 'X'.
*   Select tables
    WHEN rTable.
      PERFORM retrieveTables USING iDictionary[]
                                   soTableNames[]
                                   soAuthor[]
                                   soPack[].

*   Select message classes tables
    WHEN rMess.
      PERFORM retrieveMessageClass USING iMessages[]
                                         soAuthor[]      "Author
                                         pMname          "Message class name
                                         pMLang          "Message class language
                                         pMod            "Modified by author
                                         soPack[].       "Package

*   Select function modules
    WHEN rFunc.
      PERFORM retrieveFunctions USING soFunctionName[]   "Function name
                                      soFunctionGroup[]  "Function group
                                      iFunctions[]       "Found functions
                                      soAuthor[]         "Author
                                      pText              "Get text elements
                                      pScr               "Get screens
                                      pCust              "Customer data only
                                      customerNameSpace  "Customer name range
                                      soPack[].             "Package

*       Find Dict structures, messages, functions, includes etc.
      PERFORM scanForAdditionalFuncStuff USING iFunctions[]
                                               pRecI                   "Search for includes recursively
                                               pRecF                   "Search for functions recursively
                                               pInc                    "Search for includes
                                               pFunc                   "Search for functions
                                               pDict                   "search for dictionary objects
                                               pMess                   "Search for messages
                                               pCust                   "Customer data only
                                               customerNameSpace.      "Customer name range

*   Select Classes
    WHEN rClass.
      PERFORM retrieveClasses USING iClasses[]
                                    iFunctions[]
                                    soClassName[]       "Class name
                                    soAuthor[]          "Author
                                    customerNameSpace   "Customer name range
                                    pMod                "Also modified by author
                                    pCust               "Customer object only
                                    pMess               "Find messages
                                    pText               "Text Elements
                                    pDict               "Dictionary structures
                                    pFunc               "Get functions
                                    pInc                "Get includes
                                    pRecF               "Search recursively for functions
                                    pRecI               "Search recursively for includes
                                    pRecC               "Search recursively for classes
                                    pMLang              "Language
                                    soPack[].           "Package

      LOOP AT iFunctions.
*       Find Dict structures, messages, functions, includes etc.
        PERFORM scanForAdditionalFuncStuff USING iFunctions[]
                                                 pRecI                   "Search for includes recursively
                                                 pRecF                   "Search for functions recursively
                                                 pInc                    "Search for includes
                                                 pFunc                   "Search for functions
                                                 pDict                   "search for dictionary objects
                                                 pMess                   "Search for messages
                                                 pCust                   "Customer data only
                                                 customerNameSpace.      "Customer name range
      ENDLOOP.

*   Select programs
    WHEN rProg.
      PERFORM retrievePrograms USING iPrograms[]
                                     iProgFunctions[]
                                     soProgramName[]    "Program name
                                     soAuthor[]         "Author
                                     customerNamespace  "Customer name range
                                     pMod               "Also modified by author
                                     pCust              "Customer object only
                                     pMess              "Find messages
                                     pText              "Text Elements
                                     pDict              "Dictionay structures
                                     pFunc              "Get functions
                                     pInc               "Get includes
                                     pScr               "Get screens
                                     pRecF              "Search recursively for functions
                                     pRecI              "Search recursively for includes
                                     soPack[].             "Package
  ENDCASE.

*----------------------------------------------------------------------------------------------------------------------
end-of-selection.
*----------------------------------------------------------------------------------------------------------------------
  IF forcedExit = 0.
*   Decide what to download
    CASE 'X'.
*     Download tables
      WHEN rTable.
        IF NOT ( iDictionary[] IS INITIAL ).
          PERFORM downloadDDStructures USING iDictionary[]
                                             iDictFilename[]
                                             downloadFolder
                                             HTMLEXtension
                                             space
                                             pSortT
                                             slashSeparatorToUse
                                             pServ
                                             pProMess
                                             serverFileSystem
                                             pBack.
        ENDIF.

*     Download message class
      WHEN rMess.
        IF NOT ( iMessages[] IS INITIAL ).
          SORT iMessages ASCENDING BY arbgb msgnr.
          LOOP AT iMessages.
            APPEND iMessages TO iSingleMessageClass.
            AT END OF arbgb.
              PERFORM downloadMessageClass USING iSingleMessageClass[]
                                                 iMessages-arbgb
                                                 downloadFolder
                                                 downloadFileExtension
                                                 pHtml
                                                 space
                                                 customerNameSpace
                                                 pInc
                                                 pDict
                                                 pMess
                                                 slashSeparatorToUse
                                                 pServ
                                                 pProMess
                                                 serverFileSystem
                                                 pBack.
              CLEAR iSingleMessageClass[].
            ENDAT.
          ENDLOOP.
        ENDIF.

*     Download functions
      WHEN rFunc.
        IF NOT ( iFunctions[] IS INITIAL ).
          PERFORM downloadFunctions USING iFunctions[]
                                          iDictFilename[]
                                          downloadFolder
                                          downloadFileExtension
                                          space
                                          pFDoc
                                          pHtml
                                          customerNameSpace
                                          pInc
                                          pDict
                                          textextension
                                          htmlextension
                                          pSortT
                                          slashSeparatorToUse
                                          pServ
                                          pProMess
                                          serverFileSystem
                                          pBack.
        ENDIF.

*     Download Classes
      WHEN rClass.
        IF NOT ( iClasses[] IS INITIAL ).
          PERFORM downloadClasses USING iClasses[]
                                        iFunctions[]
                                        iDictFilename[]
                                        downloadFolder
                                        downloadFileExtension
                                        htmlextension
                                        textextension
                                        pHtml
                                        customerNameSpace
                                        pInc
                                        pDict
                                        pCDoc
                                        pSortT
                                        slashSeparatorToUse
                                        pServ
                                        pProMess
                                        serverFileSystem
                                        pBack.
        ENDIF.

*     Download programs
      WHEN rProg.
        IF NOT ( iPrograms[] IS INITIAL ).
          PERFORM downloadPrograms USING iPrograms[]
                                         iProgFunctions[]
                                         iDictFilename[]
                                         downloadFolder
                                         downloadFileExtension
                                         htmlextension
                                         textextension
                                         pHtml
                                         customerNameSpace
                                         pInc
                                         pDict
                                         '' "Documentation
                                         pSortT
                                         slashSeparatorToUse
                                         pServ
                                         pProMess
                                         serverFileSystem
                                         pBack.
        ENDIF.
    ENDCASE.

*   Free all the memory IDs we may have built up in the program
*   Free up any memory used for caching HTML versions of objects
    PERFORM freeMemory USING iPrograms[]
                             iFunctions[]
                             iProgFunctions[]
                             iDictionary[].

    IF NOT pRep IS INITIAL.
      GET TIME.
      runTime = sy-uzeit - startTime.

      CASE 'X'.
        WHEN rTable.
          PERFORM fillTreeNodeTables USING iDictionary[]
                                           iTreeDisplay[]
                                           runTime.

        WHEN rMess.
          PERFORM fillTreeNodeMessages USING iMessages[]
                                             iTreeDisplay[]
                                             runTime.


        WHEN rFunc.
          PERFORM fillTreeNodeFunctions USING iFunctions[]
                                              iTreeDisplay[]
                                              runTime.

        WHEN rClass.
          PERFORM fillTreeNodeClasses USING iClasses[]
                                            iFunctions[]
                                            iTreeDisplay[]
                                            runTime.

        WHEN rProg.
          PERFORM fillTreeNodePrograms USING iPrograms[]
                                             iProgFunctions[]
                                             iTreeDisplay[]
                                             runTime.
      ENDCASE.

      IF NOT ( iTreeDisplay[] IS INITIAL ).
        PERFORM displayTree USING iTreeDisplay[].
      ELSE.
        statusBarMessage = 'No items found matching selection criteria'.
        PERFORM displayStatus USING statusBarMessage 2.
      ENDIF.
    ENDIF.
  ENDIF.

* Clear out all the internal tables
  CLEAR iPrograms[].
  CLEAR iFunctions[].
  CLEAR iClasses[].
  CLEAR iProgFunctions[].
  CLEAR iMessages[].
  CLEAR iDictionary[].
  CLEAR iDictFilename[].

*--- Memory IDs
* User name
  SET PARAMETER ID 'MAUTH' FIELD pAuth.
* Message class
  SET PARAMETER ID 'MMNAME' FIELD pMname.
* Customer namespace
  SET PARAMETER ID 'MNAMESPACE' FIELD pCName.
* Folder
  SET PARAMETER ID 'MFOLDER' FIELD pFolder.
* Logical filepath
  SET PARAMETER ID 'MLOGICAL' FIELD pLogical.
* Text element checkbox
  SET PARAMETER ID 'MTEXT' FIELD pText.
* Messages checkbox
  SET PARAMETER ID 'MMESS' FIELD pMess.
* Includes checkbox
  SET PARAMETER ID 'MINC' FIELD pInc.
* Recursive includes checkbox.
  SET PARAMETER ID 'MRECI' FIELD pReci.
* Functions checkbox
  SET PARAMETER ID 'MFUNC' FIELD pFunc.
* Recursive functions checkbox
  SET PARAMETER ID 'MRECF' FIELD pRecf.
* Recursive classes checkbox
  SET PARAMETER ID 'MRECF' FIELD pRecC.
* Function module documentation checkbox
  SET PARAMETER ID 'MFDOC' FIELD pFDoc.
* Class documentation checkbox
  SET PARAMETER ID 'MCDOC' FIELD pCDoc.
* Screens checkbox
  SET PARAMETER ID 'MSCR' FIELD pScr.
* Dictionary checkbox
  SET PARAMETER ID 'MDICT' FIELD pDict.
* Sort table ascending checkBox
  SET PARAMETER ID 'MSORTT' FIELD pSortT.


***********************************************************************************************************************
***************************************************SUBROUTINES*********************************************************
***********************************************************************************************************************

*----------------------------------------------------------------------------------------------------------------------
*  free memory...
*----------------------------------------------------------------------------------------------------------------------
FORM freeMemory USING iLocPrograms LIKE iPrograms[]
                      iLocFunctions LIKE iFunctions[]
                      iLocProgfunctions LIKE iProgFunctions[]
                      iLocDictionary LIKE iDictionary[].

  FIELD-SYMBOLS: <wafunction> LIKE LINE OF iLocfunctions.
  FIELD-SYMBOLS: <waProgram> LIKE LINE OF iLocPrograms.
  FIELD-SYMBOLS: <waDictStruct> TYPE tDictTable.

  LOOP AT iLocFunctions ASSIGNING <waFunction>.
    LOOP AT <waFunction>-iDictStruct ASSIGNING <waDictStruct>.
      FREE MEMORY ID <waDictStruct>-tablename.
    ENDLOOP.
  ENDLOOP.

  LOOP AT iLocProgFunctions ASSIGNING <waFunction>.
    LOOP AT <waFunction>-iDictStruct ASSIGNING <waDictStruct>.
      FREE MEMORY ID <waDictStruct>-tablename.
    ENDLOOP.
  ENDLOOP.

  LOOP AT iLocPrograms ASSIGNING <waProgram>.
    LOOP AT <waProgram>-iDictStruct ASSIGNING <waDictStruct>.
      FREE MEMORY ID <waDictStruct>-tablename.
    ENDLOOP.
  ENDLOOP.

  LOOP AT iLocDictionary ASSIGNING <waDictStruct>.
    FREE MEMORY ID <waDictStruct>-tablename.
  ENDLOOP.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
*  checkComboBoxes...  Check input parameters
*----------------------------------------------------------------------------------------------------------------------
FORM checkComboBoxes.

  IF pAuth IS INITIAL.
    IF soPack[] IS INITIAL.
      CASE 'X'.
        WHEN rTable.
          IF soTable[] IS INITIAL.
            statusBarMessage = 'You must enter either a table name or author.'.
          ENDIF.
        WHEN rFunc.
          IF ( soFName[] IS INITIAL ) AND ( soFGroup[] IS INITIAL ).
            IF soFName[] IS INITIAL.
              statusBarMessage = 'You must enter either a function name or author.'.
            ELSE.
              IF soFGroup[] IS INITIAL.
                statusBarMessage = 'You must enter either a function group, or an author name.'.
              ENDIF.
            ENDIF.
          ENDIF.
        WHEN rProg.
          IF soProg[] IS INITIAL.
            statusBarMessage = 'You must enter either a program name or author name.'.
          ENDIF.
      ENDCASE.
    ENDIF.
  ELSE.
*   Check the user name of the person objects are to be downloaded for
    IF pAuth = 'SAP*' OR pauth = 'SAP'.
      statusBarMessage = 'Sorry cannot download all objects for SAP standard user'.
    ENDIF.
  ENDIF.

  IF NOT statusBarMessage IS INITIAL.
    PERFORM displayStatus USING statusBarMessage 3.
    forcedExit = 1.
    STOP.
  ENDIF.
ENDFORM.                                                                                "checkComboBoxes

*----------------------------------------------------------------------------------------------------------------------
* fillSelectionRanges...      for selection routines
*----------------------------------------------------------------------------------------------------------------------
FORM fillSelectionRanges.

  DATA: strLength TYPE i.

  strLength = strlen( pcName ).

  IF NOT pAuth IS INITIAL.
    soAuthor-sign = 'I'.
    soAuthor-option = 'EQ'.
    soAuthor-low = pAuth.
    APPEND soAuthor.
  ENDIF.

* Tables
  IF NOT soTable IS INITIAL.
    soTableNames[] = soTable[].
*   Add in the customer namespace if we need to
    IF NOT pcName IS INITIAL.
      LOOP AT soTableNames.
        IF soTableNames-low+0(strLength) <> pcName.
          CONCATENATE pcName soTableNames-low INTO soTableNames-low.
        ENDIF.

        IF soTableNames-high+0(strLength) <> pcName.
          CONCATENATE pcName soTableNames-high INTO soTableNames-high.
        ENDIF.

        MODIFY soTableNames.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Function names
  IF NOT soFName IS INITIAL.
    soFunctionName[] = soFname[].
*   Add in the customer namespace if we need to
    IF NOT pcName IS INITIAL.
      LOOP AT soFunctionName.
        IF soFunctionName-low+0(strLength) <> pcName.
          CONCATENATE pcName soFunctionName-low INTO soFunctionName-low.
        ENDIF.

        IF soFunctionName-high+0(strLength) <> pcName.
          CONCATENATE pcName soFunctionName-high INTO soFunctionName-high.
        ENDIF.

        MODIFY soFunctionName.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Function group
  IF NOT soFGroup IS INITIAL.
    soFunctionGroup[] = soFGroup[].
*   Add in the customer namespace if we need to
    IF NOT pcName IS INITIAL.
      LOOP AT soFunctionName.
        IF soFunctionGroup-low+0(strLength) <> pcName.
          CONCATENATE pcName soFunctionGroup-low INTO soFunctionGroup-low.
        ENDIF.

        IF soFunctionGroup-high+0(strLength) <> pcName.
          CONCATENATE pcName soFunctionGroup-high INTO soFunctionGroup-high.
        ENDIF.

        MODIFY soFunctionGroup.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Class names
  IF NOT soClass IS INITIAL.
    soClassName[] = soClass[].
*   Add in the customer namespace if we need to
    IF NOT pcName IS INITIAL.
      LOOP AT soClassName.
        IF soClassName-low+0(strLength) <> pcName.
          CONCATENATE pcName soClassName-low INTO soClassName-low.
        ENDIF.

        IF soClassName-high+0(strLength) <> pcName.
          CONCATENATE pcName soClassName-high INTO soClassName-high.
        ENDIF.

        MODIFY soClassName.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Program names
  IF NOT soProg IS INITIAL.
    soProgramName[] = soProg[].
*   Add in the customer namespace if we need to
    IF NOT pcName IS INITIAL.
      LOOP AT soProgramName.
        IF soProgramName-low+0(strLength) <> pcName.
          CONCATENATE pcName soProgramName-low INTO soProgramName-low.
        ENDIF.

        IF soProgramName-high+0(strLength) <> pcName.
          CONCATENATE pcName soProgramName-high INTO soProgramName-high.
        ENDIF.

        MODIFY soProgramName.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.                                                                                          " fillSelectionRanges

*----------------------------------------------------------------------------------------------------------------------
*  retrieveTables...             Search for tables in dictionary
*----------------------------------------------------------------------------------------------------------------------
FORM retrieveTables USING iLocDictStructure LIKE iDictionary[]
                          soTable LIKE soTable[]
                          soAuthor LIKE soAuthor[]
                          VALUE(soLocPackage) LIKE soPack[].

  DATA: iDictStructure TYPE STANDARD TABLE OF tDictTable.
  DATA: waDictStructure TYPE tDictTable.

  SELECT a~tabname AS tableName
         INTO CORRESPONDING FIELDS OF TABLE iDictStructure
         FROM dd02l AS a
         INNER JOIN tadir AS b
           ON a~tabname = b~obj_name
         WHERE a~tabname IN soTable
           AND a~tabclass <> 'CLUSTER'
           AND a~tabclass <> 'POOL'
           AND a~tabclass <> 'VIEW'
           AND a~as4user IN soAuthor
           AND a~as4local = 'A'
           AND b~pgmid = 'R3TR'
           AND b~object = 'TABL'
           AND b~devclass IN soLocPackage[].

  LOOP AT iDictStructure INTO waDictStructure.
    PERFORM findTableDescription USING waDictStructure-tablename
                                       waDictStructure-tableTitle.

    PERFORM findTableDefinition USING waDictStructure-tableName
                                      waDictStructure-iStructure[].

    APPEND waDictStructure TO iLocDictStructure.
    CLEAR waDictStructure.
  ENDLOOP.
ENDFORM.                                                                                                "retrieveTables

*----------------------------------------------------------------------------------------------------------------------
*  findTableDescription...  Search for table description in dictionary
*----------------------------------------------------------------------------------------------------------------------
FORM findTableDescription USING VALUE(tableName)
                                      tableDescription.

  SELECT SINGLE ddtext
                FROM dd02t
                INTO tableDescription
                WHERE tabname = tableName
                 AND ddlanguage = pMLang.
ENDFORM.                                                                                          "findTableDescription

*----------------------------------------------------------------------------------------------------------------------
*  findTableDefinition... Find the structure of a table from the SAP database.
*----------------------------------------------------------------------------------------------------------------------
FORM findTableDefinition USING VALUE(tablename)
                               iDictStruct LIKE dumIDictStructure[].

  DATA gotstate LIKE dcobjif-gotstate.
  DATA: definition TYPE STANDARD TABLE OF dd03p WITH HEADER LINE.
  DATA: waDictStruct TYPE tDictTableStructure.
  DATA: wadd02v_n TYPE dd02v.

  CALL FUNCTION 'DD_INT_TABL_GET'
    EXPORTING
      tabname        = tablename
      langu          = pmlang
    IMPORTING
      gotstate       = gotstate
      dd02v_n        = wadd02v_n
    TABLES
      dd03p_n        = definition
    EXCEPTIONS
      internal_error = 1.

  CALL FUNCTION 'DD_TABL_EXPAND'
    EXPORTING
      dd02v_wa          = wadd02v_n
      mode              = 46
      prid              = 0
    TABLES
      dd03p_tab         = definition
    EXCEPTIONS
      illegal_parameter = 1.


  IF sy-subrc = 0 AND gotstate = 'A'.
    LOOP AT definition.
      MOVE-CORRESPONDING definition TO waDictStruct.
      PERFORM removeLeadingZeros CHANGING waDictStruct-position.
      PERFORM removeLeadingZeros CHANGING waDictStruct-leng.
      APPEND waDictStruct TO iDictStruct.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                           "findTableDefinition

*----------------------------------------------------------------------------------------------------------------------
*  retrieveMessageClass...   Retrieve a message class from the SAP database
*----------------------------------------------------------------------------------------------------------------------
FORM retrieveMessageClass USING iLocMessages LIKE iMessages[]
                                rangeAuthor LIKE soAuthor[]
                                VALUE(messageClassName)
                                VALUE(messageClassLang)
                                VALUE(modifiedBy)
                                VALUE(soLocPackage) LIKE soPack[].

  DATA: waMessage TYPE tMessage.
  DATA: iMClasses TYPE STANDARD TABLE OF arbgb.


  IF NOT messageClassName IS INITIAL.
*   Check to see if the message class exists in the package
    IF NOT soLocPackage[] IS INITIAL.
      SELECT obj_name AS arbgb
             INTO TABLE iMClasses
             FROM tadir
             WHERE pgmid = 'R3TR'
               AND object = 'MSAG'
               AND devclass IN soLocPackage.
    ENDIF.

    REPLACE '*' WITH '%' INTO messageClassName.
    IF iMCLasses[] IS INITIAL.
      SELECT t100~arbgb
             t100~text
             t100~msgnr
             t100a~stext
             APPENDING CORRESPONDING FIELDS OF TABLE iLocMessages
             FROM t100
             INNER JOIN t100a
               ON t100a~arbgb = t100~arbgb
             WHERE t100a~masterLang = messageClassLang
               AND t100~sprsl = messageClassLang
               AND t100~arbgb LIKE messageClassName
               AND t100a~respUser IN rangeAuthor[].
    ELSE.
      SELECT t100~arbgb
             t100~text
             t100~msgnr
             t100a~stext
             APPENDING CORRESPONDING FIELDS OF TABLE iLocMessages
             FROM t100
             INNER JOIN t100a
               ON t100a~arbgb = t100~arbgb
             FOR ALL ENTRIES IN iMClasses
               WHERE t100~sprsl = messageClassLang
               AND ( t100~arbgb LIKE messageClassName AND t100~arbgb = iMClasses-table_line )
               AND t100a~masterLang = messageClassLang
               AND t100a~respUser IN rangeAuthor[].
    ENDIF.
  ELSE.
    IF modifiedBy IS INITIAL.
*       Select by author
      SELECT t100~arbgb                                "#EC CI_BUFFJOIN
             t100~msgnr
             t100~text
             t100a~stext
             APPENDING CORRESPONDING FIELDS OF TABLE iLocMessages
             FROM t100
             INNER JOIN t100a
               ON t100a~arbgb = t100~arbgb
             INNER JOIN tadir
               ON t100~arbgb = tadir~obj_name
             WHERE t100a~masterLang = messageClassLang
               AND t100a~respUser IN rangeAuthor[]
               AND tadir~pgmid = 'R3TR'
               AND tadir~object = 'MSAG'
               AND tadir~devclass IN soLocPackage[].

    ELSE.
*     Select also by the last person who modified the message class
      SELECT t100~arbgb                                "#EC CI_BUFFJOIN
             t100~msgnr
             t100~text
             t100a~stext
             APPENDING CORRESPONDING FIELDS OF TABLE iLocMessages
             FROM t100
             INNER JOIN t100a
               ON t100a~arbgb = t100~arbgb
             INNER JOIN tadir
               ON t100~arbgb = tadir~obj_name
             WHERE t100a~masterLang = messageClassLang
               AND t100a~respUser IN rangeAuthor[]
               AND t100a~lastUser IN rangeAuthor[]
               AND tadir~pgmid = 'R3TR'
               AND tadir~object = 'MSAG'
               AND tadir~devclass IN soLocPackage[].
    ENDIF.
  ENDIF.
ENDFORM.                                                                                          "retrieveMessageClass

*----------------------------------------------------------------------------------------------------------------------
*  retrieveFunctions...   Retrieve function modules from SAP DB.  May be called in one of two ways
*----------------------------------------------------------------------------------------------------------------------
FORM retrieveFunctions USING soFName LIKE soFunctionName[]
                             soFGroup LIKE soFunctionGroup[]
                             iLocFunctionNames LIKE iFunctions[]
                             VALUE(solocAuthor) LIKE soAuthor[]
                             VALUE(getTextElements)
                             VALUE(getScreens)
                             VALUE(customerOnly)
                             VALUE(customerNameRange)
                             VALUE(soLocPackage) LIKE soPack[].


  DATA: waFunctionName TYPE tFunction.
  DATA: noGroupsFound TYPE abap_bool VALUE true.
  DATA: previousFG TYPE v_fdir-area.

* select by function name and/or function group.
  SELECT a~funcName AS functionName
         a~area AS functionGroup
         INTO CORRESPONDING FIELDS OF TABLE iLocfunctionNames
         FROM v_fdir AS a
         INNER JOIN tlibv AS b
           ON a~area = b~area
         INNER JOIN tadir AS c
           ON a~area = c~obj_name
         WHERE a~funcName IN soFName[]
           AND a~area IN soFGroup[]
           AND a~generated = ''
           AND b~uname IN soLocAuthor[]
           AND pgmid = 'R3TR'
           AND object = 'FUGR'
           AND devclass IN solocPackage[]
           ORDER BY a~area.

  LOOP AT iLocFunctionNames INTO waFunctionName.
    PERFORM retrieveFunctionDetail USING waFunctionName-functionName
                                         waFunctionName-progname
                                         waFunctionName-includeNumber
                                         waFunctionName-functionTitle.

    PERFORM findMainFunctionInclude USING waFunctionName-progname
                                          wafunctionName-functionGroup
                                          waFunctionName-includeNumber
                                          waFunctionName-functionMainInclude.

    PERFORM findFunctionTopInclude USING waFunctionName-progname
                                         wafunctionName-functionGroup
                                         waFunctionName-topIncludeName.

*   Find all user defined includes within the function group
    PERFORM scanForFunctionIncludes USING waFunctionName-progname
                                          customerOnly
                                          customerNameRange
                                          waFunctionName-iIncludes[].
*   Find main message class
    PERFORM findMainMessageClass USING waFunctionName-progname
                                       waFunctionName-messageClass.

*   Find any screens declared within the main include
    IF NOT getScreens IS INITIAL.
      IF previousFG IS INITIAL OR previousFG <> waFunctionName-functionGroup.
        PERFORM findFunctionScreenFlow USING waFunctionName.

*       Search for any GUI texts
        PERFORM retrieveGUITitles USING waFunctionName-iGUITitle[]
                                        waFunctionName-progname.
      ENDIF.
    ENDIF.

    IF NOT getTextElements IS INITIAL.
*     Find the program texts from out of the database.
      PERFORM retrieveProgramTexts USING waFunctionName-iSelectionTexts[]
                                         waFunctionName-iTextElements[]
                                         waFunctionName-progname.
    ENDIF.

    previousFG = waFunctionName-functionGroup.
    MODIFY iLocFunctionNames FROM waFunctionName.
  ENDLOOP.
ENDFORM.                                                                                             "retrieveFunctions

*----------------------------------------------------------------------------------------------------------------------
*  retrieveFunctionDetail...   Retrieve function module details from SAP DB.
*----------------------------------------------------------------------------------------------------------------------
FORM retrieveFunctionDetail USING VALUE(functionName)
                                        progname
                                        includeName
                                        titleText.

  SELECT SINGLE pname
                include
                FROM tfdir
                INTO (progname, includeName)
                WHERE funcName = functionName.

  IF sy-subrc = 0.
    SELECT SINGLE stext
                  FROM tftit
                  INTO titleText
                  WHERE spras = pMLang
                    AND funcName = functionName.
  ENDIF.
ENDFORM.                                                                                        "retrieveFunctionDetail                                                                                  "findFunctionTopInclude

*----------------------------------------------------------------------------------------------------------------------
* scanForAdditionalFuncStuff... Search for additional things relating to functions
*----------------------------------------------------------------------------------------------------------------------
FORM scanForAdditionalFuncStuff USING iLocFunctions LIKE iFunctions[]
                                      VALUE(recursiveIncludes)
                                      VALUE(recursiveFunctions)
                                      VALUE(searchForIncludes)
                                      VALUE(searchForFunctions)
                                      VALUE(searchForDictionary)
                                      VALUE(searchForMessages)
                                      VALUE(customerOnly)
                                      VALUE(customerNameRange).

  DATA: waFunction TYPE tFunction.
  DATA: waInclude TYPE tInclude.

  LOOP AT iLocFunctions INTO waFunction.
    IF NOT searchForIncludes IS INITIAL.
*     Search in the main include
      PERFORM scanForIncludePrograms USING waFunction-functionMainInclude
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].

*     Search in the top include
      PERFORM scanForIncludePrograms USING waFunction-topIncludeName
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].
    ENDIF.

    IF NOT searchForFunctions IS INITIAL.
      PERFORM scanForFunctions USING waFunction-functionMainInclude
                                     waFunction-programLinkName
                                     recursiveIncludes
                                     recursiveFunctions
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    ENDIF.

    MODIFY iLocFunctions FROM waFunction.
  ENDLOOP.

* Now we have everthing perhaps we had better find all the dictionary structures
  IF NOT searchForDictionary IS INITIAL.
    LOOP AT iLocFunctions INTO waFunction.
      PERFORM scanForTables USING waFunction-progname
                                  customerOnly
                                  customerNameRange
                                  waFunction-iDictStruct[].

      PERFORM scanForLikeOrType USING waFunction-progname
                                      customerOnly
                                      customerNameRange
                                      waFunction-iDictStruct[].

      PERFORM scanForTables USING waFunction-functionMainInclude
                                  customerOnly
                                  customerNameRange
                                  waFunction-iDictStruct[].

      PERFORM scanForLikeOrType USING waFunction-functionMainInclude
                                      customerOnly
                                      customerNameRange
                                      waFunction-iDictStruct[].

      LOOP AT waFunction-iIncludes INTO waInclude.
        PERFORM scanForTables USING waInclude-includeName
                                    customerOnly
                                    customerNameRange
                                    waFunction-iDictStruct[].

        PERFORM scanForLikeOrType USING waInclude-includeName
                                        customerOnly
                                        customerNameRange
                                        waFunction-iDictStruct[].
      ENDLOOP.

      MODIFY iLocFunctions FROM waFunction.
    ENDLOOP.
  ENDIF.

* Now search for all messages
  IF NOT searchForMessages IS INITIAL.
    LOOP AT iLocFunctions INTO waFunction.
      PERFORM scanForMessages USING waFunction-progName
                                    waFunction-messageClass
                                    waFunction-iMessages[].
      MODIFY iLocFunctions FROM waFunction.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                    "scanForAdditionalFuncStuff

*----------------------------------------------------------------------------------------------------------------------
* scanForClasses... Search each class or method for other classes
*----------------------------------------------------------------------------------------------------------------------
FORM scanForClasses USING VALUE(className)
                          VALUE(classLinkName)
                          VALUE(customerOnly)
                          VALUE(customerNameRange)
                                iLocClasses LIKE iClasses[]
                          VALUE(soLocPackage) LIKE soPack[].

  DATA iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: head TYPE string.
  DATA: tail TYPE string.
  DATA: lineLength TYPE i VALUE 0.
  DATA: waLine TYPE string.
  DATA: waClass TYPE tClass.
  DATA: waSearchClass TYPE tClass.
  DATA: castClassName TYPE program.
  DATA: exceptionCustomerNameRange TYPE string.

* Build the name of the possible cusotmer exception classes
  CONCATENATE customerNameRange 'CX_' INTO  exceptionCustomerNameRange.

* Read the program code from the textpool.
  castClassName = className.
  READ REPORT castClassName INTO iLines.

  LOOP AT iLines INTO waLine.
*   Find custom tables.
    lineLength = strLen( waLine ).
    IF lineLength > 0.
      IF waLine(1) = asterix.
        CONTINUE.
      ENDIF.

      TRANSLATE waLine TO UPPER CASE.

      FIND typerefto IN waLine IGNORING CASE.
      IF sy-subrc = 0.
*       Have found a reference to another class
        SPLIT waLine AT type INTO head tail.
        SHIFT tail LEFT DELETING LEADING space.
        SPLIT tail AT 'REF' INTO head tail.
        SHIFT tail LEFT DELETING LEADING space.
        SPLIT tail AT 'TO' INTO head tail.
        SHIFT tail LEFT DELETING LEADING space.
        IF tail CS period.
          SPLIT tail AT period INTO head tail.
        ELSE.
          IF tail CS comma.
            SPLIT tail AT comma INTO head tail.
          ENDIF.
        ENDIF.
      ELSE.
*       Try and find classes which are only referenced through static mehods
        FIND '=>' IN waLine MATCH OFFSET sy-fdpos.
        IF sy-subrc = 0.
          head = waline+0(sy-fdpos).
          SHIFT head LEFT DELETING LEADING space.
          CONDENSE head.
          FIND 'call method' IN head IGNORING CASE.
          IF sy-subrc = 0.
            SHIFT head LEFT DELETING LEADING space.
            SPLIT head AT space INTO head tail.
            SPLIT tail AT space INTO head tail.
*           Should have the class name here
            head = tail.
          ELSE.
*           Still have a class name even though it does not have the words call method in front
            IF waLine CS '='.
              SPLIT waLine AT '=' INTO tail head.
              SHIFT head LEFT DELETING LEADING space.
              SPLIT head AT '=' INTO head tail.
            ENDIF.
            sy-subrc = 0.
          ENDIF.
        ENDIF.
      ENDIF.

      IF sy-subrc = 0.
        TRY.
            IF head+0(1) = 'Y' OR head+0(1) = 'Z' OR head CS customerNameRange.
*           We have found a class best append it to our class table if we do not already have it.
              READ TABLE iLocClasses INTO waSearchClass WITH KEY clsName = head.
              IF sy-subrc <> 0.
                IF head+0(3) = 'CX_'
                   OR head+0(4) = 'ZCX_'
                   OR head+0(4) = 'YCX_'
                   OR head CS exceptionCustomerNameRange.

                  waClass-exceptionClass = true.
                ENDIF.

                waClass-clsname = head.

*             Check the package
                IF NOT soLocPackage[] IS INITIAL.
                  SELECT SINGLE obj_name
                         FROM tadir
                         INTO waClass-clsName
                         WHERE pgmid = 'R3TR'
                           AND object = 'CLAS'
                           AND obj_name = waClass-clsName
                           AND devclass IN soLocPackage[].
                  IF sy-subrc = 0.
                    APPEND waClass TO iLocClasses.
                  ENDIF.
                ELSE.
                  APPEND waClass TO iLocClasses.
                ENDIF.
              ENDIF.
            ENDIF.
          CATCH cx_sy_range_out_of_bounds.
        ENDTRY.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                                "scanForClasses

*----------------------------------------------------------------------------------------------------------------------
* scanForIncludePrograms... Search each program for include programs
*----------------------------------------------------------------------------------------------------------------------
FORM scanForIncludePrograms USING VALUE(programName)
                                  VALUE(recursiveIncludes)
                                  VALUE(customerOnly)
                                  VALUE(customerNameRange)
                                        iLocIncludes LIKE dumiIncludes[].

  DATA: iIncludeLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iKeywords TYPE STANDARD TABLE OF text20 WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: waTokens TYPE stokes.
  DATA: waInclude TYPE tInclude.
  DATA: waIncludeExists TYPE tInclude.
  DATA: maxLines TYPE i.
  DATA: nextLine TYPE i.
  DATA: castProgramName TYPE program.

* Read the program code from the textpool.
  castProgramName = programName.
  READ REPORT castProgramName INTO iIncludeLines.

  APPEND include TO iKeywords.
  SCAN ABAP-SOURCE iIncludeLines TOKENS INTO iTokens WITH INCLUDES STATEMENTS INTO iStatements KEYWORDS FROM iKeywords.

  CLEAR iIncludeLines[].

  maxLines = lines( iTokens ).
  LOOP AT iTokens WHERE str = include AND type = 'I'.
    nextLine = sy-tabix + 1.
    IF nextLine <= maxLines.
      READ TABLE iTokens INDEX nextLine INTO waTokens.

*      Are we only to find customer includes?
      IF NOT customerOnly IS INITIAL.
        TRY.
            IF waTokens-str+0(1) = 'Y' OR waTokens-str+0(1) = 'Z' OR waTokens-str CS customerNameRange
               OR waTokens-str+0(2) = 'MZ' OR waTokens-str+0(2) = 'MY'.

            ELSE.
              CONTINUE.
            ENDIF.
          CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
        ENDTRY.
      ENDIF.

      waInclude-includeName = waTokens-str.

*      Best find the program title text as well.
      PERFORM findProgramOrIncludeTitle USING waInclude-includeName
                                              waInclude-includeTitle.

*      Don't append the include if we already have it listed
      READ TABLE iLocIncludes INTO waIncludeExists WITH KEY includeName = waInclude-includeName.
      IF sy-subrc <> 0.
        APPEND waInclude TO iLocIncludes.

        IF NOT recursiveIncludes IS INITIAL.
*          Do a recursive search for other includes
          PERFORM scanForIncludePrograms USING waInclude-includeName
                                               recursiveIncludes
                                               customerOnly
                                               customerNameRange
                                               iLocIncludes[].
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                        "scanForIncludePrograms

*----------------------------------------------------------------------------------------------------------------------
* scanForFunctions... Search each program for function modules
*----------------------------------------------------------------------------------------------------------------------
FORM scanForFunctions USING VALUE(programName)
                            VALUE(programLinkName)
                            VALUE(recursiveIncludes)
                            VALUE(recursiveFunctions)
                            VALUE(customerOnly)
                            VALUE(customerNameRange)
                                  iLocFunctions LIKE iFunctions[].

  DATA: iIncludeLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: waTokens TYPE stokes.
  DATA: waFunction TYPE tFunction.
  DATA: waFunctionComparison TYPE tFunction.
  DATA: maxLines TYPE i.
  DATA: nextLine TYPE i.
  DATA: castProgramName TYPE program.
  DATA: skipThisloop TYPE abap_bool.

* Read the program code from the textpool.
  castProgramName = programName.
  READ REPORT castProgramName INTO iIncludeLines.
  SCAN ABAP-SOURCE iIncludeLines TOKENS INTO iTokens WITH INCLUDES STATEMENTS INTO iStatements.
  CLEAR iIncludeLines[].

  maxLines = lines( iTokens ).
  LOOP AT iTokens WHERE str = function AND type = 'I'.

    nextLine = sy-tabix + 1.
    IF nextLine <= maxLines.
      READ TABLE iTokens INDEX nextLine INTO waTokens.

*      Are we only to find customer functions
      skipThisLoop = false.
      IF NOT customerOnly IS INITIAL.
        TRY.
            IF waTokens-str+1(1) = 'Y' OR waTokens-str+1(1) = 'Z' OR waTokens-str CS customerNameRange.
            ELSE.
              skipThisLoop = true.
            ENDIF.
          CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
          CLEANUP.
            skipThisLoop = true.
        ENDTRY.
      ENDIF.

      IF skipThisLoop = false.
        waFunction-functionName = waTokens-str.
        REPLACE ALL OCCURRENCES OF '''' IN waFunction-functionName WITH ' '.
        CONDENSE waFunction-functionName.

*        Don't add a function if we alread have it listed.
        READ TABLE iLocFunctions WITH KEY functionName = waFunction-functionName INTO waFunctionComparison.
        IF sy-subrc <> 0.
*          Add in the link name if the function is linked to a program
          waFunction-programLinkName = programLinkName.

*          Don't download functions which are called through an RFC destination
          nextline = sy-tabix + 2.
          READ TABLE iTokens INDEX nextLine INTO waTokens.
          IF waTokens-str <> destination.

*            Find the function group
            SELECT SINGLE area FROM v_fdir INTO wafunction-functionGroup WHERE funcName = waFunction-functionName.

            IF sy-subrc = 0.
*              Best find the function number as well.
              PERFORM retrieveFunctionDetail USING waFunction-functionName
                                                   waFunction-progname
                                                   waFunction-includeNumber
                                                   waFunction-functionTitle.

              PERFORM findMainFunctionInclude USING waFunction-progname
                                                    waFunction-functionGroup
                                                    waFunction-includeNumber
                                                    waFunction-functionMainInclude.

              PERFORM findFunctionTopInclude USING waFunction-progname
                                                   wafunction-functionGroup
                                                   waFunction-topIncludeName.

*              Find main message class
              PERFORM findMainMessageClass USING waFunction-progname
                                                 waFunction-messageClass.

              APPEND waFunction TO iLocFunctions.

*              Now lets search a little bit deeper and do a recursive search for other includes
              IF NOT recursiveIncludes IS INITIAL.
                PERFORM scanForIncludePrograms USING waFunction-functionMainInclude
                                                     recursiveIncludes
                                                     customerOnly
                                                     customerNameRange
                                                     waFunction-iIncludes[].
              ENDIF.

*              Now lets search a little bit deeper and do a recursive search for other functions
              IF NOT recursiveFunctions IS INITIAL.
                PERFORM scanForFunctions USING waFunction-functionMainInclude
                                               space
                                               recursiveIncludes
                                               recursiveFunctions
                                               customerOnly
                                               customerNameRange
                                               iLocFunctions[].
              ENDIF.
              CLEAR waFunction.
            ENDIF.
          ENDIF.
        ENDIF.

        CLEAR waFunction.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                              "scanForFunctions

*----------------------------------------------------------------------------------------------------------------------
*  scanForFunctionIncludes... Find all user defined includes within the function group
*----------------------------------------------------------------------------------------------------------------------
FORM scanForFunctionIncludes USING poolName
                                   VALUE(customerOnly)
                                   VALUE(customerNameRange)
                                   iLocIncludes LIKE dumiIncludes[].

  DATA: iIncludeLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iKeywords TYPE STANDARD TABLE OF text20 WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: waTokens TYPE stokes.
  DATA: waInclude TYPE tInclude.
  DATA: waIncludeExists TYPE tInclude.
  DATA: maxLines TYPE i.
  DATA: nextLine TYPE i.
  DATA: castProgramName TYPE program.

* Read the program code from the textpool.
  castProgramName = poolName.
  READ REPORT castProgramName INTO iIncludeLines.

  APPEND include TO iKeywords.
  SCAN ABAP-SOURCE iIncludeLines TOKENS INTO iTokens WITH INCLUDES STATEMENTS INTO iStatements KEYWORDS FROM iKeywords.

  CLEAR iIncludeLines[].

  maxLines = lines( iTokens ).
  LOOP AT iTokens WHERE str = include AND type = 'I'.
    nextLine = sy-tabix + 1.
    IF nextLine <= maxLines.
      READ TABLE iTokens INDEX nextLine INTO waTokens.

      IF waTokens-str CP '*F++'.
*        Are we only to find customer includes?
        IF NOT customerOnly IS INITIAL.
          TRY.
              IF waTokens-str+0(2) = 'LY' OR waTokens-str+0(2) = 'LZ' OR waTokens-str CS customerNameRange.
              ELSE.
                CONTINUE.
              ENDIF.
            CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
          ENDTRY.
        ENDIF.

        waInclude-includeName = waTokens-str.

*        Best find the program title text as well.
        PERFORM findProgramOrIncludeTitle USING waInclude-includeName
                                                waInclude-includeTitle.

*        Don't append the include if we already have it listed
        READ TABLE iLocIncludes INTO waIncludeExists WITH KEY includeName = waInclude-includeName.
        IF sy-subrc <> 0.
          APPEND waInclude TO iLocIncludes.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                       "scanForFunctionIncludes

*----------------------------------------------------------------------------------------------------------------------
*  findProgramOrIncludeTitle...   Finds the title text of a program.
*----------------------------------------------------------------------------------------------------------------------
FORM findProgramOrIncludeTitle USING VALUE(programName)
                                           titleText.

  SELECT SINGLE text
                FROM trdirt
                INTO titleText
                WHERE name = programName
                  AND sprsl = pMLang.
ENDFORM.                                                                                     "findProgramOrIncludeTitle

*----------------------------------------------------------------------------------------------------------------------
* retrievePrograms...    find programs and sub objects from SAP DB
*----------------------------------------------------------------------------------------------------------------------
FORM retrievePrograms USING iLocProgram LIKE iPrograms[]
                            iLocFunctions LIKE iFunctions[]
                            rangeProgram LIKE soProgramName[]
                            rangeAuthor LIKE soAuthor[]
                            VALUE(custNameRange)
                            VALUE(alsoModifiedByauthor)
                            VALUE(customerProgsOnly)
                            VALUE(getMessages)
                            VALUE(getTextElements)
                            VALUE(getCustDictStructures)
                            VALUE(getFunctions)
                            VALUE(getIncludes)
                            VALUE(getScreens)
                            VALUE(recursiveFuncSearch)
                            VALUE(recursiveIncludeSearch)
                            VALUE(soLocPackage) LIKE soPack[].

  DATA: waRangeProgram LIKE LINE OF rangeProgram.

  IF rangeProgram[] IS INITIAL.
*   We are finding all programs by an author
    PERFORM findAllProgramsForAuthor USING iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           soLocPackage[].
  ELSE.
    READ TABLE rangeProgram INDEX 1 INTO waRangeProgram.
    IF waRangeProgram-low CS asterix.
      PERFORM findProgramsByWildcard USING iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           customerProgsOnly
                                           soLocPackage[].
    ELSE.
      PERFORM checkProgramDoesExist USING iLocProgram[]
                                          rangeProgram[].
    ENDIF.
  ENDIF.

* Find extra items
  PERFORM scanForAdditionalProgStuff USING iLocProgram[]
                                           iLocFunctions[]
                                           getTextElements
                                           getMessages
                                           getScreens
                                           getCustDictStructures
                                           getFunctions
                                           getIncludes
                                           customerProgsOnly
                                           custNameRange
                                           recursiveIncludeSearch
                                           recursiveFuncSearch.
ENDFORM.                                                                               "retrievePrograms

*-------------------------------------------------------------------------------------------------------
*  scanForAdditionalProgStuff...
*-------------------------------------------------------------------------------------------------------
FORM scanForAdditionalProgStuff USING iLocProgram LIKE iPrograms[]
                                      iLocFunctions LIKE iFunctions[]
                                      VALUE(getTextElements)
                                      VALUE(getMessages)
                                      VALUE(getScreens)
                                      VALUE(getCustDictStructures)
                                      VALUE(getFunctions)
                                      VALUE(getIncludes)
                                      VALUE(customerOnly)
                                      VALUE(customerNameRange)
                                      VALUE(recursiveIncludeSearch)
                                      VALUE(recursiveFuncSearch).

  DATA: waProgram TYPE tProgram.
  DATA: waInclude TYPE tInclude.
  DATA: myTabix TYPE syTabix.

* Best to find all the includes used in a program first
  IF NOT getIncludes IS INITIAL.
    LOOP AT iLocProgram INTO waProgram.
      myTabix = sy-tabix.
      PERFORM scanForIncludePrograms USING waProgram-progName
                                           recursiveIncludeSearch
                                           customerOnly
                                           customerNameRange
                                           waProgram-iIncludes[].

      MODIFY iLocProgram FROM waProgram INDEX myTabix.
    ENDLOOP.
  ENDIF.

* Once we have a list of all the includes we need to loop round them an select all the other objects
  LOOP AT iLocProgram INTO waProgram.
    myTabix = sy-tabix.
    PERFORM findProgramDetails USING waProgram-progName
                                     waProgram-subc
                                     waProgram-programTitle
                                     waProgram
                                     getTextElements
                                     getMessages
                                     getScreens
                                     getCustDictStructures
                                     customerOnly
                                     customerNameRange.

*   Find any screens
    IF NOT getScreens IS INITIAL.
      PERFORM findProgramScreenFlow USING waProgram.
    ENDIF.

    LOOP AT waProgram-iIncludes INTO waInclude.
      PERFORM findProgramDetails USING waInclude-includeName
                                       'I'
                                       waInclude-includeTitle
                                       waProgram
                                       getTextElements
                                       getMessages
                                       getScreens
                                       getCustDictStructures
                                       customerOnly
                                       customerNameRange.
    ENDLOOP.

    MODIFY iLocProgram FROM waProgram INDEX myTabix.
  ENDLOOP.

* Now we have all the program includes and details we need to find extra functions
  IF NOT getFunctions IS INITIAL.
    LOOP AT iLocProgram INTO waProgram.
*     Find any functions defined in the code
      PERFORM scanForFunctions USING waProgram-progname
                                     waProgram-progname
                                     space
                                     space
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    ENDLOOP.
  ENDIF.

* We have a list of all the functions so lets go and find details and other function calls
  PERFORM scanForAdditionalFuncStuff USING iLocFunctions[]
                                           recursiveIncludeSearch
                                           recursiveFuncSearch
                                           getIncludes
                                           getFunctions
                                           getCustDictStructures
                                           getMessages
                                           customerOnly
                                           customerNameRange.
ENDFORM.                                                                     "scanForAdditionalProgStuff

*-------------------------------------------------------------------------------------------------------
*  findProgramDetails...
*-------------------------------------------------------------------------------------------------------
FORM findProgramDetails USING VALUE(programName)
                              VALUE(programType)
                                    programTitle
                                    waProgram TYPE tProgram
                              VALUE(getTextElements)
                              VALUE(getMessages)
                              VALUE(getScreens)
                              VALUE(getCustDictStructures)
                              VALUE(customerOnly)
                              VALUE(customerNameRange).

  PERFORM findProgramOrIncludeTitle USING programName
                                          programTitle.

  IF NOT getTextElements IS INITIAL.
*   Find the program texts from out of the database.
    PERFORM retrieveProgramTexts USING waProgram-iSelectionTexts[]
                                       waProgram-iTextElements[]
                                       programName.
  ENDIF.

* Search for any GUI texts
  IF NOT getScreens IS INITIAL AND ( programType = 'M' OR programType = '1' ).
    PERFORM retrieveGUITitles USING waProgram-iGUITitle[]
                                    programName.
  ENDIF.

* Find individual messages
  IF NOT getMessages IS INITIAL.
    IF programType = 'M' OR programType = '1'.
      PERFORM findMainMessageClass USING programName
                                         waProgram-messageClass.
    ENDIF.

    PERFORM scanForMessages USING programName
                                  waProgram-messageClass
                                  waProgram-iMessages[].
  ENDIF.

  IF NOT getCustDictStructures IS INITIAL.
    PERFORM scanForTables USING programName
                                customerOnly
                                customerNameRange
                                waProgram-iDictStruct[].

    PERFORM scanForLikeOrType USING programName
                                    customerOnly
                                    customerNameRange
                                    waProgram-iDictStruct[].
  ENDIF.
ENDFORM.                                                                             "findProgramDetails

*-------------------------------------------------------------------------------------------------------
*  findAllProgramsForAuthor...
*-------------------------------------------------------------------------------------------------------
FORM findAllProgramsForAuthor USING iLocProgram LIKE iPrograms[]
                                    rangeProgram LIKE soProgramName[]
                                    rangeAuthor LIKE soAuthor[]
                                    VALUE(custNameRange)
                                    VALUE(alsoModifiedByauthor)
                                    VALUE(customerProgsOnly)
                                    VALUE(soLocPackage) LIKE soPack[].

  DATA: altCustomerNameRange TYPE string.
  FIELD-SYMBOLS: <waProgram> TYPE tProgram.
  DATA: genFlag TYPE genFlag.

* build up the customer name range used for select statements
  CONCATENATE custNameRange '%' INTO altCustomerNameRange.

* select by name and author
  IF NOT alsoModifiedByAuthor IS INITIAL.
*   Programs modified by author
*   Program to search for is an executable program
    IF customerProgsOnly IS INITIAL.
*     Select all programs
      SELECT a~progname
             a~subc
             APPENDING CORRESPONDING FIELDS OF TABLE ilocProgram
             FROM reposrc AS a
             INNER JOIN tadir AS b
               ON a~progname = b~obj_name
             WHERE a~progname IN rangeProgram
               AND a~cnam IN rangeAuthor
               AND ( a~subc = '1' OR a~subc = 'M' OR a~subc = 'S' )
               AND b~pgmid = 'R3TR'
               AND b~object = 'PROG'
               AND b~devclass IN soLocPackage.

    ELSE.
*     Select only customer specific programs
      SELECT progname
             subc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             FROM reposrc AS a
             INNER JOIN tadir AS b
               ON a~progname = b~obj_name
             WHERE a~progname  IN rangeProgram
               AND ( a~progname LIKE altCustomerNameRange
                     OR a~progname LIKE 'Z%'
                     OR a~progname LIKE 'Y%'
                     OR a~progname LIKE 'SAPMZ%'
                     OR a~progname LIKE 'SAPMY%')
               AND a~cnam IN rangeAuthor
               AND ( a~subc = '1' OR a~subc = 'M' OR a~subc = 'S' )
               AND b~pgmid = 'R3TR'
               AND b~object = 'PROG'
               AND b~devclass IN soLocPackage.
    ENDIF.
  ELSE.

*   Programs created by author
    IF customerProgsOnly IS INITIAL.
*     Select all programs
      SELECT progname
             subc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             FROM reposrc AS a
             INNER JOIN tadir AS b
               ON a~progname = b~obj_name
             WHERE a~progname IN rangeProgram
               AND ( a~subc = '1' OR a~subc = 'M' OR a~subc = 'S' )
               AND ( a~cnam IN rangeAuthor OR a~unam IN rangeAuthor )
               AND b~pgmid = 'R3TR'
               AND b~object = 'PROG'
               AND b~devclass IN soLocPackage.
    ELSE.
*     Select only customer specific programs
      SELECT a~progname
             a~subc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             FROM reposrc AS a
             INNER JOIN tadir AS b
               ON a~progname = b~obj_name
             WHERE a~progname IN rangeProgram
               AND ( a~progname LIKE altCustomerNameRange
                     OR a~progname LIKE 'Z%'
                     OR a~progname LIKE 'Y%'
                     OR a~progname LIKE 'SAPMZ%'
                     OR a~progname LIKE 'SAPMY%')
               AND ( a~subc = '1' OR a~subc = 'M' OR a~subc = 'S' )
               AND ( a~cnam IN rangeAuthor OR a~unam IN rangeAuthor )
               AND b~pgmid = 'R3TR'
               AND b~object = 'PROG'
               AND b~devclass IN soLocPackage.
    ENDIF.
  ENDIF.
ENDFORM.                                                                       "findAllProgramsForAuthor

*-------------------------------------------------------------------------------------------------------
*  checkProgramDoesExist...
*-------------------------------------------------------------------------------------------------------
FORM checkProgramDoesExist USING iLocProgram LIKE iPrograms[]
                                 rangeProgram LIKE soProgramName[].

*  Check to see if the program is an executable program
  SELECT progname
         subc
         INTO CORRESPONDING FIELDS OF TABLE iLocProgram
         FROM reposrc
         WHERE progname IN rangeProgram
           AND ( subc = '1' OR
                 subc = 'I' OR
                 subc = 'M' OR
                 subc = 'S' ).
ENDFORM.                                                                          "checkProgramDoesExist

*-------------------------------------------------------------------------------------------------------
*  findProgramsByWildcard.. Search in the system for programs
*-------------------------------------------------------------------------------------------------------
FORM findProgramsByWildcard USING iLocProgram LIKE iPrograms[]
                                  VALUE(rangeProgram) LIKE soProgramName[]
                                  VALUE(rangeAuthor) LIKE soAuthor[]
                                  VALUE(custNameRange)
                                  VALUE(customerProgsOnly)
                                  VALUE(soLocPackage) LIKE soPack[].

  DATA: altCustomerNameRange TYPE string.
  FIELD-SYMBOLS: <waProgram> TYPE tProgram.
  DATA: genFlag TYPE genFlag.

  IF customerProgsOnly IS INITIAL.
*   build up the customer name range used for select statements
    IF custNameRange <> '^'.
      CONCATENATE custNameRange '%' INTO altCustomerNameRange.

      SELECT progname
             subc
             FROM reposrc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             WHERE progname  IN rangeProgram
               AND progname LIKE altCustomerNameRange
               AND ( subc = '1' OR subc = 'M' OR subc = 'S' )
               AND ( cnam IN rangeAuthor OR unam IN rangeAuthor ).
    ELSE.
      SELECT progname
             subc
             FROM reposrc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             WHERE progname  IN rangeProgram
               AND ( subc = '1' OR subc = 'M' OR subc = 'S' )
               AND ( cnam IN rangeAuthor OR unam IN rangeAuthor ).
    ENDIF.
  ELSE.
*   Only customer programs
    IF custNameRange <> '^'.
      CONCATENATE custNameRange '%' INTO altCustomerNameRange.

      SELECT progname
             subc
             FROM reposrc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             WHERE progname  IN rangeProgram
               AND ( progname LIKE altCustomerNameRange
                     OR progname LIKE 'Z%'
                     OR progname LIKE 'Y%'
                     OR progname LIKE 'SAPMZ%'
                     OR progname LIKE 'SAPMY%')
               AND ( subc = '1' OR subc = 'M' OR subc = 'S' )
               AND ( cnam IN rangeAuthor OR unam IN rangeAuthor ).
    ELSE.
      SELECT progname
             subc
             FROM reposrc
             APPENDING CORRESPONDING FIELDS OF TABLE iLocProgram
             WHERE progname  IN rangeProgram
             AND ( progname LIKE 'Z%'
                   OR progname LIKE 'Y%'
                   OR progname LIKE 'SAPMZ%'
                   OR progname LIKE 'SAPMY%')
             AND ( subc = '1' OR subc = 'M' OR subc = 'S' )
             AND ( cnam IN rangeAuthor OR unam IN rangeAuthor ).
    ENDIF.
  ENDIF.
ENDFORM.                                                                         "findProgramsByWildcard

*-------------------------------------------------------------------------------------------------------
*  retrieveProgramTexts... Find the text elements and selection texts for a program
*-------------------------------------------------------------------------------------------------------
FORM retrieveProgramTexts USING iLocSelectionTexts LIKE dumiTextTab[]
                                iLocTextElements LIKE dumiTextTab[]
                                VALUE(programName).

  DATA: iTextTable TYPE STANDARD TABLE OF tTextTable WITH HEADER LINE.
  DATA: waTexts TYPE tTextTable.
  DATA: castProgramName(50).

  MOVE programName TO castProgramName.

  READ TEXTPOOL castProgramName INTO iTextTable LANGUAGE pMLang.
  DELETE iTextTable WHERE key = 'R'.

* Selection texts.
  LOOP AT iTextTable WHERE id = 'S'.
    MOVE iTextTable-key TO waTexts-key.
    MOVE iTextTable-entry TO waTexts-entry.
    APPEND waTexts TO iLocSelectiontexts.
    CLEAR waTexts.
  ENDLOOP.

* Text elements.
  DELETE iTextTable WHERE key = 'S'.
  LOOP AT iTextTable WHERE id = 'I'.
    MOVE iTextTable-key TO waTexts-key.
    MOVE iTextTable-entry TO waTexts-entry.
    APPEND waTexts TO iLocTextElements.
  ENDLOOP.
ENDFORM.                                                                           "retrieveProgramTexts

*-------------------------------------------------------------------------------------------------------
*  retrieveGUITitles...  Search for any GUI texts
*-------------------------------------------------------------------------------------------------------
FORM retrieveGUITitles USING iLocGUITitle LIKE dumIGUITitle[]
                             VALUE(programName).

  SELECT obj_code
         text
         FROM d347t
         APPENDING CORRESPONDING FIELDS OF TABLE iLocGUItitle
         WHERE progname = programName.
ENDFORM.                                                                              "retrieveGUITitles

*-------------------------------------------------------------------------------------------------------
*   findMainMessageClass... find the message class stated at the top of  program.
*-------------------------------------------------------------------------------------------------------
FORM findMainMessageClass USING VALUE(programName)
                                      messageClass.

  SELECT SINGLE msgid
                FROM trdire INTO messageClass
                WHERE report = programName.
ENDFORM.                                                                           "findMainMessageClass

*-------------------------------------------------------------------------------------------------------
* retrieveClasses...    find classes and sub objects from SAP DB
*-------------------------------------------------------------------------------------------------------
FORM retrieveClasses USING iLocClasses LIKE iClasses[]
                           iLocFunctions LIKE iFunctions[]
                           rangeClass LIKE soClassName[]
                           rangeAuthor LIKE soAuthor[]
                           VALUE(custNameRange)
                           VALUE(alsoModifiedByauthor)
                           VALUE(customerProgsOnly)
                           VALUE(getMessages)
                           VALUE(getTextElements)
                           VALUE(getCustDictStructures)
                           VALUE(getFunctions)
                           VALUE(getIncludes)
                           VALUE(recursiveFuncSearch)
                           VALUE(recursiveIncludeSearch)
                           VALUE(recursiveClassSearch)
                           VALUE(language)
                           VALUE(soLocPackage) LIKE soPack[].

  DATA: waRangeClass LIKE LINE OF rangeClass.
  DATA: waClass LIKE LINE OF iLocCLasses[].

  IF rangeClass[] IS INITIAL.
*   We are finding all programs by an author
    PERFORM findAllClassesForAuthor USING iLocClasses[]
                                           rangeClass[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           language.
  ELSE.
    READ TABLE rangeClass INDEX 1 INTO waRangeClass.
    IF waRangeClass-low CS asterix.
      PERFORM findClassesByWildcard USING iLocClasses[]
                                          rangeClass[]
                                          rangeAuthor[]
                                          custNameRange
                                          customerProgsOnly
                                          language.
    ELSE.
      PERFORM checkClassDoesExist USING iLocClasses[]
                                        rangeClass[].
    ENDIF.
  ENDIF.

* Check the package
  IF NOT soLocPackage[] IS INITIAL.
    LOOP AT iLocClasses INTO waClass.
      SELECT SINGLE obj_name
             FROM tadir
             INTO waClass-clsName
             WHERE pgmid = 'R3TR'
               AND object = 'CLAS'
               AND obj_name = waClass-clsName
               AND devclass IN soLocPackage[].
      IF sy-subrc <> 0.
        DELETE iLocClasses.
      ENDIF.
    ENDLOOP.
  ENDIF.

* Find extra items
  IF NOT iLocClasses[] IS INITIAL.
    PERFORM scanForAdditionalClassStuff USING iLocClasses[]
                                              iLocFunctions[]
                                              getTextElements
                                              getMessages
                                              getCustDictStructures
                                              getFunctions
                                              getIncludes
                                              customerProgsOnly
                                              custNameRange
                                              recursiveIncludeSearch
                                              recursiveFuncSearch
                                              recursiveClassSearch
                                              soLocPackage[].
  ENDIF.
ENDFORM.                                                                                "retrieveClasses

*-------------------------------------------------------------------------------------------------------
*  findAllClassesForAuthor...
*-------------------------------------------------------------------------------------------------------
FORM findAllClassesForAuthor USING iLocClass LIKE iClasses[]
                                   rangeClass LIKE soClassName[]
                                   rangeAuthor LIKE soAuthor[]
                                   VALUE(custNameRange)
                                   VALUE(alsoModifiedByauthor)
                                   VALUE(customerClassesOnly)
                                   VALUE(language).

  DATA: altCustomerNameRange TYPE string.

* build up the customer name range used for select statements
  CONCATENATE custNameRange '%' INTO altCustomerNameRange.

* select by name and author
  IF NOT alsoModifiedByAuthor IS INITIAL.
*   Classes modified by author
    IF customerClassesOnly IS INITIAL.
*     Select all classes
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND langu = language
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).

      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
               AND langu = language
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ELSE.
*     Select only customer specific classes
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND ( clsname LIKE altCustomerNameRange
                     OR clsname LIKE 'Z%'
                     OR clsname LIKE 'Y%')
               AND langu = language
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).

      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND ( clsname LIKE altCustomerNameRange
                       OR clsname LIKE 'Z%'
                       OR clsname LIKE 'Y%')
                 AND langu = language
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ENDIF.
  ELSE.
*   Programs created by author
    IF customerClassesOnly IS INITIAL.
*     Select all classes
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND langu = language
               AND author IN rangeAuthor
               AND version = '1'
               AND ( state = '0' OR state = '1' ).

      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND langu = language
                 AND author IN rangeAuthor
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ELSE.
*     Select only customer specific classes
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND ( clsname LIKE altCustomerNameRange
                     OR clsname LIKE 'Z%'
                     OR clsname LIKE 'Y%')
               AND langu = language
               AND author IN rangeAuthor
               AND version = '1'
               AND ( state = '0' OR state = '1' ).

      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND ( clsname LIKE altCustomerNameRange
                       OR clsname LIKE 'Z%'
                       OR clsname LIKE 'Y%')
                 AND langu = language
                 AND author IN rangeAuthor
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                                                                        "findAllClassesForAuthor

*-------------------------------------------------------------------------------------------------------
*  findClassesByWildcard...  Find classes using a wildcard search
*-------------------------------------------------------------------------------------------------------
FORM findClassesByWildcard USING iLocClass LIKE iClasses[]
                                 rangeClass LIKE soClassName[]
                                 VALUE(rangeAuthor) LIKE soAuthor[]
                                 VALUE(custNameRange)
                                 VALUE(customerClassesOnly)
                                 VALUE(language).

  DATA: altCustomerNameRange TYPE string.

  IF customerClassesOnly IS INITIAL.
*   Searching for customer and SAP classes
    IF custNameRange <> '^'.
*     build up the customer name range used for select statements
      CONCATENATE custNameRange '%' INTO altCustomerNameRange.

      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND clsname LIKE custNameRange
               AND langu = language
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).
      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND clsname LIKE custNameRange
                 AND langu = language
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ELSE.
*     Searching using normal name ranges
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND langu = language
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).
      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND langu = language
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ENDIF.
  ELSE.
*   searching for only customer classes
    IF custNameRange <> '^'.
*     build up the customer name range used for select statements
      CONCATENATE custNameRange '%' INTO altCustomerNameRange.

      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND clsname LIKE custNameRange
               AND langu = language
               AND ( clsname LIKE 'ZC%' OR clsname LIKE 'YC%' )
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).
      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND langu = language
                 AND ( clsname LIKE 'ZC%' OR clsname LIKE 'YC%' )
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ELSE.
*     Searching using normal name ranges
      SELECT clsname descript msg_id
             FROM vseoclass
             APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
             WHERE clsname IN rangeClass
               AND ( clsname LIKE 'ZC%' OR clsname LIKE 'YC%' )
               AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
               AND version = '1'
               AND ( state = '0' OR state = '1' ).
      IF sy-subrc <> 0.
        SELECT clsname descript msg_id
               FROM vseoclass
               APPENDING CORRESPONDING FIELDS OF TABLE ilocClass
               WHERE clsname IN rangeClass
                 AND ( clsname LIKE 'ZC%' OR clsname LIKE 'YC%' )
                 AND ( author IN rangeAuthor OR changedby IN rangeAuthor )
                 AND version = '0'
                 AND ( state = '0' OR state = '1' ).
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                                                                          "findClassesByWildcard

*-------------------------------------------------------------------------------------------------------
*  checkClassDoesExist...
*-------------------------------------------------------------------------------------------------------
FORM checkClassDoesExist USING iLocClass LIKE iClasses[]
                               rangeClass LIKE soClassName[].

  DATA: waClass TYPE tClass.

  SELECT SINGLE clsname descript msg_id
         FROM vseoclass
         INTO CORRESPONDING FIELDS OF waClass
         WHERE clsname IN rangeClass
           AND version = '1'
           AND ( state = '0' OR state = '1' ).

  IF sy-subrc <> 0.
    SELECT SINGLE clsname descript msg_id
         FROM vseoclass
         INTO CORRESPONDING FIELDS OF waClass
         WHERE clsname IN rangeClass
           AND version = '0'
           AND ( state = '0' OR state = '1' ).
  ENDIF.

  IF NOT waClass-clsname IS INITIAL.
    APPEND waClass TO iLocClass.
  ENDIF.
ENDFORM.                                                                            "checkClassDoesExist

*-------------------------------------------------------------------------------------------------------
*  scanForAdditionalClassStuff...
*-------------------------------------------------------------------------------------------------------
FORM scanForAdditionalClassStuff USING iLocClasses LIKE iClasses[]
                                       iLocFunctions LIKE iFunctions[]
                                       VALUE(getTextElements)
                                       VALUE(getMessages)
                                       VALUE(getCustDictStructures)
                                       VALUE(getFunctions)
                                       VALUE(getIncludes)
                                       VALUE(customerOnly)
                                       VALUE(customerNameRange)
                                       VALUE(recursiveIncludeSearch)
                                       VALUE(recursiveFuncSearch)
                                       VALUE(recursiveClassSearch)
                                       VALUE(soLocPackage) LIKE soPack[].

  DATA: waClass TYPE tClass.
  DATA: waMethod TYPE tMethod.
  DATA: myTabix TYPE syTabix.
  DATA: scanningForClasses TYPE abap_bool VALUE false.
  DATA: classNewLines TYPE i VALUE 0.
  DATA: classCurrentLines TYPE i VALUE 0.

  LOOP AT iLocClasses INTO waClass WHERE scanned IS INITIAL.
*  Once we have a list of all the classes we need to loop round them an select all the other objects
    myTabix = sy-tabix.
    PERFORM findClassDetails USING waClass-clsName
                                   waClass
                                   iLocFunctions[]
                                   getTextElements
                                   getMessages
                                   getFunctions
                                   getCustDictStructures
                                   customerOnly
                                   customerNameRange.

*   Set the scanned class so we do not check them again when running recursively.
    waClass-scanned = 'X'.
    MODIFY iLocClasses FROM waClass INDEX myTabix.
  ENDLOOP.

* Now we have all the classes and details we need to find extra classes
  IF NOT recursiveClassSearch IS INITIAL.
    classCurrentLines = lines( iLocClasses ).
    LOOP AT iLocClasses INTO waClass.
*     Don't try and find any other details for an exception class
      IF ( waClass-clsName NS 'ZCX_' OR waClass-clsName NS 'CX_'  ).
*       Find any classes defined in the main class definition
        PERFORM scanForClasses USING waClass-privateClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        PERFORM scanForClasses USING waClass-publicClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        PERFORM scanForClasses USING waClass-protectedClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        LOOP AT waClass-iMethods INTO waMethod.
*         Find any classes defined in any of the methods
          PERFORM scanForClasses USING waMethod-methodKey
                                       waClass-clsname
                                       customerOnly
                                       customerNameRange
                                       iLocClasses[]
                                       soLocPackage[].
        ENDLOOP.
      ENDIF.
    ENDLOOP.

*   We have a list of all the classes so lets go and find their details
    classNewLines = lines( iLocClasses ).
    IF classNewLines > classCurrentLines.
      PERFORM scanForAdditionalClassStuff USING iLocClasses[]
                                                iLocFunctions[]
                                                getTextElements
                                                getMessages
                                                getCustDictStructures
                                                getFunctions
                                                getIncludes
                                                customerOnly
                                                customerNameRange
                                                recursiveIncludeSearch
                                                recursiveFuncSearch
                                                recursiveClassSearch
                                                soLocPackage[].
    ENDIF.
  ENDIF.
ENDFORM.                                                                   "scanForAdditionalClassStuff

*-------------------------------------------------------------------------------------------------------
*  findClassDetails...
*-------------------------------------------------------------------------------------------------------
FORM findClassDetails USING VALUE(className)
                                  waClass TYPE tClass
                                  iLocFunctions LIKE iFunctions[]
                                  VALUE(getTextElements)
                                  VALUE(getMessages)
                                  VALUE(getFunctions)
                                  VALUE(getCustDictStructures)
                                  VALUE(customerOnly)
                                  VALUE(customerNameRange).

  DATA: iEmptySelectionTexts TYPE STANDARD TABLE OF tTextTable.
  DATA: myTabix TYPE syTabix.
  DATA: waMethod TYPE tMethod.
  DATA: rnBlankAuthor LIKE soAuthor[].
  DATA: rnBlankPackage LIKE soPack[].
  DATA: waInterface TYPE tInterface.

* Build up the keys we will use for finding data
  PERFORM buildClassKeys USING waClass.

  IF waClass-descript IS INITIAL.
    PERFORM findClassDescription USING className
                                       waClass-descript.
  ENDIF.

* Find the class attributes.
  SELECT SINGLE exposure msg_id state clsfinal r3release
                FROM vseoclass
                INTO (waClass-exposure, waClass-msg_id, waClass-state,
                      waClass-clsfinal, waClass-r3release)
                WHERE clsName = waClass-clsName.

* Don't try and find any other details for an exception class
  IF ( waClass-clsName CS 'ZCX_' OR waClass-clsName CS 'CX_'  ).
*   Exception texts
    PERFORM findExceptionTexts USING waClass-publicClassKey
                                     waClass-iConcepts[].
    waClass-scanned = 'X'.
  ELSE.
    IF NOT getTextElements IS INITIAL.
*     Find the class texts from out of the database.
      PERFORM retrieveProgramTexts USING iEmptySelectionTexts[]
                                         waClass-iTextElements[]
                                         waClass-textElementKey.
    ENDIF.

*   Find any declared dictionary structures
    IF NOT getCustDictStructures IS INITIAL.
      PERFORM scanForTables USING waClass-privateClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      PERFORM scanForTables USING waClass-publicClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      PERFORM scanForTables USING waClass-protectedClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      PERFORM scanForTables USING waClass-typesClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      PERFORM scanForLikeOrType USING waClass-privateClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      PERFORM scanForLikeOrType USING waClass-publicClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      PERFORM scanForLikeOrType USING waClass-protectedClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      PERFORM scanForLikeOrType USING waClass-typesClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].
    ENDIF.

*   Find all the interfaces used in this class
    PERFORM findClassInterfaces USING className
                                      waClass-iInterfaces[].

*   Find all the methods defined by the interfaces
    PERFORM findInterfaceMethods USING className
                                       waClass-iInterfaces[]
                                       waClass-iMethods[].

*   Methods
*   Find all the methods for this class
    PERFORM findClassMethods USING className
                                   waClass-iMethods[].

    LOOP AT waClass-iMethods[] INTO waMethod.
      myTabix = sy-tabix.
*     Find individual messages
      IF NOT getMessages IS INITIAL.
        PERFORM scanForMessages USING waMethod-methodKey
                                      waClass-msg_id
                                      waClass-iMessages[].
      ENDIF.

      IF NOT getCustDictStructures IS INITIAL.
*       Find any declared dictionary structures
        PERFORM scanForTables USING waMethod-methodKey
                                    customerOnly
                                    customerNameRange
                                    waClass-iDictStruct[].

        PERFORM scanForLikeOrType USING waMethod-methodKey
                                        customerOnly
                                        customerNameRange
                                        waClass-iDictStruct[].
      ENDIF.

      IF NOT getfunctions IS INITIAL.
        PERFORM scanForFunctions USING waMethod-methodKey
                                       waClass-clsName
                                       space
                                       space
                                       customerOnly
                                       customerNameRange
                                       iLocFunctions[].
      ENDIF.

      MODIFY waClass-iMethods FROM waMethod INDEX myTabix.
    ENDLOOP.

*   If the class has specified a message class but were unable to find any specific messages
*   then retrieve the whole message class.
    IF ( NOT waClass-msg_id IS INITIAL AND waClass-iMessages[] IS INITIAL ).
      PERFORM retrieveMessageClass USING waClass-iMessages[]
                                         rnBlankAuthor[]
                                         waClass-msg_id
                                         pMLang
                                         ''
                                         rnBlankPackage[].
    ENDIF.
  ENDIF.
ENDFORM.                                                                               "findClassDetails

*----------------------------------------------------------------------------------------------------------------------
* Find all interface methods used by the class
*----------------------------------------------------------------------------------------------------------------------
FORM findInterfaceMethods USING VALUE(className)
                                      iLocInterfaces LIKE dumiInterfaces[]
                                      iLocMethods LIKE dumiMethods[].

  TYPES: BEGIN OF tIntMethod,
           interfaceName LIKE vseomethod-clsname,
           cmpName       LIKE vseomethod-cmpname,
           exposure      LIKE vseomethod-exposure,
         END OF tIntMethod.
  DATA: waMethod TYPE tMethod.
  DATA: waInterface LIKE LINE OF iLocInterfaces.
  DATA: iIntMethod TYPE STANDARD TABLE OF tIntMethod WITH HEADER LINE.

  LOOP AT iLocInterfaces INTO waInterface.
    SELECT a~clsname AS interfaceName
           a~cmpName
           b~exposure
           APPENDING TABLE iIntMethod
           FROM seocompo AS a
           INNER JOIN seocompodf AS b
             ON a~clsname = b~clsname
             AND a~cmpname = b~cmpname
           WHERE a~clsname = waInterface-interfaceName.
  ENDLOOP.

  LOOP AT iIntMethod.
    CONCATENATE iIntMethod-interfaceName '~' iIntMethod-cmpname INTO waMethod-cmpname.
    waMethod-exposure = iIntMethod-exposure.

    SELECT SINGLE descript
           FROM seocompotx
           INTO waMethod-descript
           WHERE clsname = iIntMethod-interfaceName
             AND cmpname = iIntMethod-cmpname
             AND langu = pMLang.

    PERFORM findMethodKey USING className
                                waMethod-cmpName
                                waMethod-methodKey.

    IF NOT waMethod-methodKey IS INITIAL.
      APPEND waMethod TO iLocMethods.
    ENDIF.

    CLEAR waMethod.
  ENDLOOP.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
*   Check to see if their are any interfaces being used by this class
*----------------------------------------------------------------------------------------------------------------------
FORM findClassInterfaces USING VALUE(className)
                                     iLocInterfaces LIKE dumiInterfaces[].

  DATA: isInheritance TYPE abap_bool VALUE abap_true.
  DATA: iInterfaces TYPE STANDARD TABLE OF vseoimplem WITH HEADER LINE.
  DATA: waLocInterface LIKE LINE OF iLocInterfaces.

  SELECT * FROM vseoimplem
           INTO TABLE iInterfaces
           WHERE clsname = className.

  WHILE isInheritance = abap_true.
    PERFORM findClassParent USING className
                                  className.

    IF className IS INITIAL.
      isInheritance = abap_false.
    ELSE.
      SELECT * FROM vseoimplem
               APPENDING TABLE iInterfaces
               WHERE clsname = className.
    ENDIF.
  ENDWHILE.

  IF NOT iInterfaces[] IS INITIAL.
    SORT iInterfaces ASCENDING BY refclsname.
    DELETE ADJACENT DUPLICATES FROM iInterfaces COMPARING refclsname.

    LOOP AT iInterfaces.
      waLocInterface-interfaceName = iInterfaces-refclsname.
      APPEND wALocInterface TO iLocInterfaces.
    ENDLOOP.
  ENDIF.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
*  Find the parent of the current class
*----------------------------------------------------------------------------------------------------------------------
FORM findClassParent USING VALUE(className)
                                 parentClassName.

  DATA: waInheritance TYPE seor_inheritance_r.
  DATA: clskey TYPE seoclskey.

  clskey-clsname = className.

  CALL FUNCTION 'SEO_INHERITANC_READ'
    EXPORTING
      clskey             = clskey
      version            = seoc_version_active
    IMPORTING
      inheritance        = waInheritance
*     redefinitions      = redefinitions
    EXCEPTIONS
      class_not_existing = 1.

  parentClassName = waInheritance-refclsname.
ENDFORM.

*-------------------------------------------------------------------------------------------------------
*  buildClassKeys...   Finds the title text of a class.
*-------------------------------------------------------------------------------------------------------
FORM buildClassKeys USING waClass TYPE tClass.

  DATA: classNameLength TYPE i.
  DATA: loops TYPE i.

  classNameLength = strlen( waClass-clsName ).

  cl_oo_classname_service=>get_pubsec_name( EXPORTING clsname = waClass-clsName
                                            RECEIVING result = waClass-publicClassKey ).

  cl_oo_classname_service=>get_prisec_name( EXPORTING clsname = waClass-clsName
                                            RECEIVING result = waClass-privateClassKey ).

  cl_oo_classname_service=>get_prosec_name( EXPORTING clsname = waClass-clsName
                                            RECEIVING result = waClass-protectedClassKey ).


* Text element key - length of text element key has to be 32 characters.
  loops = 30 - classNameLength.
  waClass-textElementKey = waClass-clsName.
  DO loops TIMES.
    CONCATENATE waClass-textElementKey '=' INTO waClass-textElementKey.
  ENDDO.
* Save this for later.
  CONCATENATE waClass-textElementKey 'CP' INTO waClass-textElementKey.

* Types Class key - length of class name has to be 32 characters.
  loops = 30 - classNameLength.
  waClass-typesClassKey = waClass-clsName.
  DO loops TIMES.
    CONCATENATE waClass-typesClassKey '=' INTO waClass-typesClassKey.
  ENDDO.
* Save this for later
  CONCATENATE waClass-typesClassKey 'CT' INTO waClass-typesClassKey.
ENDFORM.                                                                                 "buildClassKeys

*-------------------------------------------------------------------------------------------------------
*  findClassDescription...   Finds the title text of a class.
*-------------------------------------------------------------------------------------------------------
FORM findClassDescription USING VALUE(className)
                                      titleText.

  SELECT SINGLE descript
                FROM vseoclass
                INTO titleText
                WHERE clsname = className
                  AND langu = pMLang.
  IF sy-subrc <> 0.
    SELECT SINGLE descript
                  FROM vseoclass
                  INTO titleText
                  WHERE clsname = className.
  ENDIF.
ENDFORM.                                                                           "findClassDescription

*-------------------------------------------------------------------------------------------------------
*  findExceptionTexts...   Fiond the texts of an exception class.
*-------------------------------------------------------------------------------------------------------
FORM findExceptionTexts USING publicClassKey
                              iConcepts LIKE dumiConcepts[].

  DATA: castClassName TYPE program.
  DATA: iTempLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iKeywords TYPE STANDARD TABLE OF text20 WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: waTokens TYPE stokes.
  DATA: waCurrentToken TYPE stokes.
  DATA: waConcept LIKE LINE OF iConcepts.
  DATA: tokenLength TYPE i.
  DATA: myRow TYPE i.

  castClassName = publicClassKey.
  READ REPORT castClassName INTO iTempLines.

  APPEND 'CONSTANTS' TO iKeywords.
  SCAN ABAP-SOURCE iTempLines TOKENS INTO iTokens STATEMENTS INTO iStatements KEYWORDS FROM iKeywords.

  DELETE iTokens WHERE str = 'CONSTANTS'.
  DELETE iTokens WHERE str = 'VALUE'.
  DELETE iTokens WHERE str = 'TYPE'.

  LOOP AT iTokens INTO waTokens WHERE str = 'SOTR_CONC'.
*   The loop before holds the constant name
    myRow = sy-tabix - 1.
    READ TABLE iTokens INDEX myRow INTO waCurrentToken.
    waConcept-constName = waCurrentToken-str.

*   The loop after holds the constant name
    myRow = myRow + 2.
    READ TABLE iTokens INDEX myRow INTO waCurrentToken.
    tokenLength = strLen( waCurrentToken-str ).
    IF tokenLength = 34.
*     Most likely an exception text.
      REPLACE ALL OCCURRENCES OF '''' IN waCurrentToken-str WITH ' ' .
      waConcept-concept = waCurrentToken-str.
      APPEND waConcept TO iConcepts.
    ENDIF.
  ENDLOOP.
ENDFORM.

*-------------------------------------------------------------------------------------------------------
*  findClassMethods...   Finds the methods of a class.
*-------------------------------------------------------------------------------------------------------
FORM findClassMethods USING VALUE(className)
                            iLocMethods LIKE dumiMethods[].

  DATA: iMethods TYPE STANDARD TABLE OF tMethod WITH HEADER LINE.
  DATA: iRedefinedMethods TYPE STANDARD TABLE OF seoredef WITH HEADER LINE.
  DATA: originalClassName TYPE seoclsname.
  DATA: waMethod LIKE LINE OF iMethods.

  SELECT cmpName descript exposure
         FROM vseomethod
         INTO CORRESPONDING FIELDS OF TABLE iMethods
           WHERE clsname = className
             AND version = '1'
             AND langu = pMLang
             AND ( state = '0' OR state = '1' ).

  IF sy-subrc <> 0.
    SELECT cmpName descript exposure
           FROM vseomethod
           INTO CORRESPONDING FIELDS OF TABLE iMethods
           WHERE clsname = className
             AND version = '0'
             AND langu = pMLang
             AND ( state = '0' OR state = '1' ).
  ENDIF.

  SELECT *
         FROM seoredef
         INTO TABLE iRedefinedMethods
         WHERE clsname = className
           AND version = '1'.

*  For Each method we must find the original class the method was created in
  LOOP AT iRedefinedMethods.
    PERFORM findRedefinitionClass USING iRedefinedMethods-refclsname
                                        iRedefinedMethods-mtdname
                                        originalClassName.

    waMethod-cmpname = iRedefinedMethods-mtdname.

    SELECT SINGLE descript exposure
        FROM vseomethod
        INTO CORRESPONDING FIELDS OF  waMethod
          WHERE clsname = originalClassName
            AND cmpname = iRedefinedMethods-mtdname
            AND version = '1'
            AND langu = pMLang
            AND ( state = '0' OR state = '1' ).

    CONCATENATE `Redefined: ` waMethod-descript INTO waMethod-descript.
    APPEND waMethod TO iMethods.
  ENDLOOP.

* Find the method key so that we can acces the source code later
  LOOP AT iMethods.
    PERFORM findMethodKey USING className
                                iMethods-cmpName
                                iMethods-methodKey.
    APPEND iMethods TO iLocMethods.
  ENDLOOP.
ENDFORM.                                                                               "findClassMethods

*-------------------------------------------------------------------------------------------------------
* findRedefinitionClass... find the original class the method was redefined from
*-------------------------------------------------------------------------------------------------------
FORM findRedefinitionClass USING VALUE(redefinedClassName) TYPE seoclsname
                                 VALUE(methodName) TYPE seocpdname
                                       originalClassName TYPE seoclsname.

  DATA: waRedef TYPE seoredef.

  SELECT SINGLE *
         FROM seoredef
         INTO waRedef
         WHERE refclsName = redefinedClassName
           AND mtdname = methodName.

  IF sy-subrc = 0.
*   There is a higher class still.
    originalClassName = waRedef-refclsName.
    PERFORM findRedefinitionClassRecur USING waRedef-refclsname
                                             waRedef-mtdname
                                             originalClassName.
  ELSE.
*   We are at the higher class.
    originalClassName = waRedef-refclsName.
  ENDIF.
ENDFORM.

*-------------------------------------------------------------------------------------------------------
* findRedefinitionClassRecur... Recursively find the original class the method was redefined from
*-------------------------------------------------------------------------------------------------------
FORM findRedefinitionClassRecur USING VALUE(redefinedClassName) TYPE seoclsname
                                 VALUE(methodName) TYPE seocpdname
                                       originalClassName TYPE seoclsname.

  DATA: waRedef TYPE seoredef.

  SELECT SINGLE *
         FROM seoredef
         INTO waRedef
         WHERE clsName = redefinedClassName
           AND mtdname = methodName.

  IF sy-subrc = 0.
*   There is a higher class still.
    originalClassName = waRedef-refclsName.
    PERFORM findRedefinitionClassRecur USING waRedef-refclsname
                                             waRedef-mtdname
                                             originalClassName.
  ENDIF.
ENDFORM.

*-------------------------------------------------------------------------------------------------------
* findMethodKey... find the unique key which identifes this method
*-------------------------------------------------------------------------------------------------------
FORM findMethodKey USING VALUE(className)
                         VALUE(methodName)
                               methodKey.

  DATA: methodID TYPE seocpdkey.
  DATA: locMethodKey TYPE program.

  methodID-clsname = className.
  methodID-cpdName = methodName.

  cl_oo_classname_service=>get_method_include( EXPORTING mtdkey = methodID
                                               RECEIVING result = locMethodKey
                                               EXCEPTIONS class_not_existing = 1
                                                          method_not_existing = 2 ).

  methodKey = locMethodKey.
ENDFORM.                                                                                  "findMethodKey

*-------------------------------------------------------------------------------------------------------
* scanForMessages... Search each program for messages
*-------------------------------------------------------------------------------------------------------
FORM scanForMessages USING VALUE(programName)
                           VALUE(mainMessageClass)
                                 iLocMessages LIKE iMessages[].

  DATA: iIncludeLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: iKeywords TYPE STANDARD TABLE OF text20 WITH HEADER LINE.
  DATA: waMessage TYPE tMessage.
  DATA: waMessageComparison TYPE tMessage.
  DATA: watokens TYPE stokes.
  DATA: nextLine TYPE i.
  DATA: stringLength TYPE i VALUE 0.
  DATA: workingOnMessage TYPE abap_bool VALUE false.
  DATA: castProgramName TYPE program.

* Read the program code from the textpool.
  castProgramName = programName.
  READ REPORT castProgramName INTO iIncludeLines.

  APPEND message TO iKeywords.
  SCAN ABAP-SOURCE iIncludeLines TOKENS INTO iTokens WITH INCLUDES STATEMENTS INTO iStatements KEYWORDS FROM iKeywords.

  CLEAR iIncludeLines[].

  LOOP AT iTokens.
    IF iTokens-str = message.
      workingOnMessage = true.
      CONTINUE.
    ENDIF.

    IF workingOnMessage = true.
      stringLength = strlen( iTokens-str ).

*     Message declaration 1
      IF stringLength = 4 AND iTokens-str+0(1) CA sy-abcde.
        waMessage-msgnr = iTokens-str+1(3).
        waMessage-arbgb = mainMessageClass.
      ELSE.
        IF iTokens-str CS '''' OR iTokens-str CS '`'.
*         Message declaration 2
          TRANSLATE iTokens-str USING ''' '.
          TRANSLATE iTokens-str USING '` '.
          CONDENSE iTokens-str.
          SHIFT iTokens-str LEFT DELETING LEADING space.
          waMessage-text = iTokens-str.
          waMessage-arbgb = 'Hard coded'.
        ELSE.
          IF iTokens-str = 'ID'.
*           Message declaration 3
            nextLine = sy-tabix + 1.
            READ TABLE iTokens INDEX nextLine INTO waTokens.
            TRANSLATE waTokens-str USING ''' '.
            CONDENSE iTokens-str.
            SHIFT waTokens-str LEFT DELETING LEADING space.
            IF NOT waTokens-str = 'SY-MSGID'.
              waMessage-arbgb = waTokens-str.

              nextLine = nextLine + 4.
              READ TABLE iTokens INDEX nextLine INTO waTokens.
              TRANSLATE waTokens-str USING ''' '.
              CONDENSE waTokens-str.
              SHIFT waTokens-str LEFT DELETING LEADING space.
              waMessage-msgnr = waTokens-str.
            ELSE.
              workingOnMessage = false.
            ENDIF.
          ELSE.
            IF stringLength >= 5 AND iTokens-str+4(1) = '('.
*              Message declaration 4
              waMessage-msgnr = iTokens-str+1(3).
              SHIFT iTokens-str LEFT UP TO '('.
              REPLACE '(' INTO iTokens-str WITH space.
              REPLACE ')' INTO iTokens-str WITH space.
              CONDENSE iTokens-str.
              waMessage-arbgb = iTokens-str.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

*      find the message text
      IF NOT waMessage-arbgb IS INITIAL AND NOT waMessage-msgnr IS INITIAL AND waMessage-text IS INITIAL.
        SELECT SINGLE text
                      FROM t100
                      INTO waMessage-text
                      WHERE sprsl = pMLang
                        AND arbgb = waMessage-arbgb
                        AND msgnr = waMessage-msgnr.
      ENDIF.

*      Append the message
      IF NOT waMessage IS INITIAL.
        IF NOT waMessage-text IS INITIAL.
*          Don't append the message if we already have it listed
          READ TABLE iLocMessages WITH KEY arbgb = waMessage-arbgb
                                           msgnr = waMessage-msgnr
                                           INTO waMessageComparison.
          IF sy-subrc <> 0.
            APPEND waMessage TO iLocMessages.
          ENDIF.
        ENDIF.
        CLEAR waMessage.
        workingOnMessage = false.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                 "scanForMessages

*-------------------------------------------------------------------------------------------------------
* scanForTables... Search each program for dictionary tables
*-------------------------------------------------------------------------------------------------------
FORM scanForTables USING VALUE(programName)
                         VALUE(customerOnly)
                         VALUE(customerNameRange)
                               iLocDictionary LIKE iDictionary[].

  DATA: iIncludeLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTokens TYPE STANDARD TABLE OF stokes WITH HEADER LINE.
  DATA: iStatements TYPE STANDARD TABLE OF sstmnt WITH HEADER LINE.
  DATA: iKeywords TYPE STANDARD TABLE OF text20 WITH HEADER LINE.
  DATA: waDictionary TYPE tDictTable.
  DATA: waDictionaryComparison TYPE tDictTable.
  DATA: castProgramName TYPE program.

* Read the program code from the textpool.
  castProgramName = programName.
  READ REPORT castProgramName INTO iIncludeLines.

  APPEND tables TO iKeywords.

  SCAN ABAP-SOURCE iIncludeLines TOKENS INTO iTokens WITH INCLUDES STATEMENTS INTO iStatements KEYWORDS FROM iKeywords.
  CLEAR iIncludeLines[].

  SORT iTokens ASCENDING BY str.
  DELETE iTokens WHERE str = tables.

  LOOP AT iTokens.
    IF NOT CustomerOnly IS INITIAL.
      TRY.
          CASE iTokens-str+0(1).
            WHEN 'Y' OR 'Z' OR customerNameRange.
            WHEN OTHERS.
              CONTINUE.
          ENDCASE.
*        if ( iTokens-str+0(1) <> 'Y' or iTokens-str+0(1) <> 'Z' or iTokens-str ns customerNameRange ).
*          continue.
*        endif.
        CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
      ENDTRY.
    ENDIF.

    waDictionary-tablename = iTokens-str.
*   Don't append the object if we already have it listed
    READ TABLE iLocDictionary INTO waDictionaryComparison WITH KEY tablename = waDictionary-tableName.
    IF sy-subrc <> 0.
      PERFORM findTableDescription USING waDictionary-tablename
                                         waDictionary-tableTitle.

      PERFORM findTableDefinition USING waDictionary-tableName
                                        waDictionary-iStructure[].

      APPEND waDictionary TO iLocDictionary.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                 "scanForTables

*-------------------------------------------------------------------------------------------------------
*  findProgramScreenFlow...
*-------------------------------------------------------------------------------------------------------
FORM findProgramScreenFlow USING waProgram TYPE tProgram.

  DATA: iFlow TYPE STANDARD TABLE OF tScreenFlow WITH HEADER LINE.

  CALL FUNCTION 'DYNPRO_PROCESSINGLOGIC'
    EXPORTING
      rep_name  = waProgram-progname
    TABLES
      scr_logic = iFlow.

  SORT iFlow ASCENDING BY screen.
  DELETE ADJACENT DUPLICATES FROM iFlow COMPARING screen.
  IF waProgram-subc <> 'M'.
    DELETE iFlow WHERE screen >= '1000' AND screen <= '1099'.
  ENDIF.

  LOOP AT iFlow.
    APPEND iFlow TO waProgram-iScreenFlow.
  ENDLOOP.
ENDFORM.                                                                          "findProgramScreenFlow

*----------------------------------------------------------------------------------------------------------------------
*  findMainFunctionInclude...  Find the main include that contains the source code
*----------------------------------------------------------------------------------------------------------------------
FORM findMainFunctionInclude USING VALUE(programName)
                                   VALUE(functionGroup)
                                   VALUE(functionIncludeNo)
                                         functionIncludeName.

  DATA: namespace        TYPE string,
        iResults         TYPE match_result_tab,
        waResult         TYPE match_result,
        startingPosition TYPE i.

  FIND ALL OCCURRENCES OF '/' IN functionGroup RESULTS iResults.
  IF sy-subrc = 0.
    READ TABLE iResults INDEX sy-tfill INTO waResult.
    startingPosition = waResult-offset + 1.
    namespace = functiongroup+0(startingPosition).
    functionGroup = functionGroup+startingPosition.
  ENDIF.

  CONCATENATE namespace 'L' functionGroup 'U' functionIncludeNo INTO functionIncludeName.
ENDFORM.                                                                                       "findMainFunctionInclude

*----------------------------------------------------------------------------------------------------------------------
*  findFunctionTopInclude...  Find the top include for the function group
*----------------------------------------------------------------------------------------------------------------------
FORM findFunctionTopInclude USING VALUE(programName)
                                  VALUE(functionGroup)
                                        topIncludeName.

  DATA: namespace        TYPE string,
        iResults         TYPE match_result_tab,
        waResult         TYPE match_result,
        startingPosition TYPE i.

  FIND ALL OCCURRENCES OF '/' IN functionGroup RESULTS iResults.
  IF sy-subrc = 0.
    READ TABLE iResults INDEX sy-tfill INTO waResult.
    startingPosition = waResult-offset + 1.
    namespace = functiongroup+0(startingPosition).
    functionGroup = functionGroup+startingPosition.
  ENDIF.

  CONCATENATE namespace 'L' functionGroup 'TOP' INTO topIncludeName.
ENDFORM.                                                                                        "findFunctionTopInclude

*-------------------------------------------------------------------------------------------------------
*  findFunctionScreenFlow...
*-------------------------------------------------------------------------------------------------------
FORM findFunctionScreenFlow USING waFunction TYPE tFunction.

  DATA: iFlow TYPE STANDARD TABLE OF tScreenFlow WITH HEADER LINE.

  CALL FUNCTION 'DYNPRO_PROCESSINGLOGIC'
    EXPORTING
      rep_name  = waFunction-progName
    TABLES
      scr_logic = iFlow.

  SORT iFlow ASCENDING BY screen.
  DELETE ADJACENT DUPLICATES FROM iFlow COMPARING screen.

  LOOP AT iFlow.
    APPEND iFlow TO waFunction-iScreenFlow.
  ENDLOOP.
ENDFORM.                                                                          "findFunctionScreenFlow

*-------------------------------------------------------------------------------------------------------
* scanForLikeOrType... Look for any dictionary objects referenced by a like or type statement
*-------------------------------------------------------------------------------------------------------
FORM scanForLikeOrType USING VALUE(programName)
                             VALUE(customerOnly)
                             VALUE(customerNameRange)
                             iLocDictionary LIKE iDictionary[].

  DATA iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: head TYPE string.
  DATA: tail TYPE string.
  DATA: junk TYPE string.
  DATA: lineType TYPE string.
  DATA: lineLength TYPE i VALUE 0.
  DATA: endOfLine TYPE abap_bool VALUE true.
  DATA: waDictionary TYPE tDictTable.
  DATA: waDictionaryComparison TYPE tDictTable.
  DATA: waLine TYPE string.
  DATA: castProgramName TYPE program.

* Read the program code from the textpool.
  castProgramName = programName.
  READ REPORT castProgramName INTO iLines.

  LOOP AT iLines INTO waLine.
*   Find custom tables.
    lineLength = strLen( waLine ).
    IF lineLength > 0.
      IF waLine(1) = asterix.
        CONTINUE.
      ENDIF.

      TRANSLATE waLine TO UPPER CASE.

*     Determine the lineType.
      IF endOfLine = true.
        SHIFT waLine UP TO like.
        IF sy-subrc = 0.
          lineType = like.
        ELSE.
          SHIFT waLine UP TO type.
          IF sy-subrc = 0.
            FIND 'BEGIN OF' IN waLine.
            IF sy-subrc <> 0.
              FIND 'END OF' IN waLine.
              IF sy-subrc <> 0.
                FIND 'VALUE' IN waLine.
                IF sy-subrc <> 0.
                  lineType = type.
                ENDIF.
              ENDIF.
            ENDIF.
          ELSE.
            SHIFT waLine UP TO include.
            IF sy-subrc = 0.
              SPLIT waLine AT space INTO junk iLines.
            ENDIF.

            SHIFT waLine UP TO structure.
            IF sy-subrc = 0.
              lineType = structure.
            ELSE.
              CONTINUE.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        lineType = comma.
      ENDIF.

      CASE linetype.
        WHEN like OR type OR structure.
*         Work on the appropriate lineType
          SHIFT waLine UP TO space.
          SHIFT waLine LEFT DELETING LEADING space.
          IF waLine CS table.
            SPLIT waLine AT table INTO head tail.
            SPLIT tail AT 'OF' INTO head tail.
            waLine = tail.
            SHIFT waLine LEFT DELETING LEADING space.
            REPLACE ALL OCCURRENCES OF 'WITH HEADER LINE' IN waLine WITH ''.
          ENDIF.

*         Are we only to download SAP dictionary structures.
          IF NOT CustomerOnly IS INITIAL.
            TRY.
                IF waLine+0(1) = 'Y' OR waLine+0(1) = 'Z' OR waLine CS customerNameRange.
                ELSE.
                  lineType = ''.
                  CONTINUE.
                ENDIF.
              CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
            ENDTRY.
          ENDIF.

          IF waLine CS comma.
            SPLIT waLine AT comma INTO head tail.
            IF waLine CS dash.
              SPLIT head AT dash INTO head tail.
            ENDIF.
            IF waLine CS occurs.
              SPLIT waLine AT space INTO head tail.
            ENDIF.
          ELSE.
            IF waLine CS period.
              SPLIT waLine AT period INTO head tail.
              IF waLine CS dash.
                SPLIT head AT dash INTO head tail.
              ENDIF.
              IF waLine CS occurs.
                SPLIT waLine AT space INTO head tail.
              ENDIF.
            ELSE.
              SPLIT waLine AT space INTO head tail.
              IF waLine CS dash.
                SPLIT head AT dash INTO head tail.
              ENDIF.
            ENDIF.
          ENDIF.

          IF NOT head IS INITIAL.
            waDictionary-tableName = head.
*           Don't append the object if we already have it listed
            READ TABLE iLocDictionary INTO waDictionaryComparison
                                      WITH KEY tablename = waDictionary-tableName.
            IF sy-subrc <> 0.
              PERFORM findTableDescription USING waDictionary-tablename
                                                 waDictionary-tableTitle.

              PERFORM findTableDefinition USING waDictionary-tableName
                                                waDictionary-iStructure[].

*             Only append if the item is a table and not a structure or data element
              IF NOT waDictionary-iStructure[] IS INITIAL.
                APPEND waDictionary TO iLocDictionary.
              ENDIF.
            ENDIF.
            CLEAR waDictionary.
          ENDIF.

          lineType = ''.
      ENDCASE.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                              "scanForLikeOrType

*-------------------------------------------------------------------------------------------------------
*  displayStatus...
*-------------------------------------------------------------------------------------------------------
FORM displayStatus USING VALUE(message)
                         VALUE(delay).

  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      percentage = 0
      text       = message
    EXCEPTIONS
      OTHERS     = 1.

  IF delay > 0.
    WAIT UP TO delay SECONDS.
  ENDIF.
ENDFORM.                                                                                  "displayStatus

*-------------------------------------------------------------------------------------------------------
*  removeLeadingZeros...
*-------------------------------------------------------------------------------------------------------
FORM removeLeadingZeros CHANGING myValue.

  CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
    EXPORTING
      input  = myValue
    IMPORTING
      output = myValue
    EXCEPTIONS
      OTHERS = 1.
ENDFORM.                                                                             "removeLeadingZeros

*-------------------------------------------------------------------------------------------------------
* determineFrontendOPSystem.... Determine the frontend operating system type.
*-------------------------------------------------------------------------------------------------------
FORM determineFrontendOPSystem USING separator
                                     operatingSystem.

  DATA: platformID TYPE i VALUE 0.

  CREATE OBJECT objFile.

  CALL METHOD objFile->get_platform
    RECEIVING
      platform             = platformID
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3.
  CASE platformID.
    WHEN objFile->platform_windows95
         OR objFile->platform_windows98
         OR objFile->platform_nt351
         OR objFile->platform_nt40
         OR objFile->platform_nt50
         OR objFile->platform_mac
         OR objFile->platform_os2
         OR 14.      "XP
      separator = '\'.
      operatingSystem = non_unix.
    WHEN OTHERS.
      separator = '/'.
      operatingSystem = unix.
  ENDCASE.
ENDFORM.                                                                      "determineFrontendOpSystem

*-------------------------------------------------------------------------------------------------------
* determineServerOPSystem.... Determine the server operating system type.
*-------------------------------------------------------------------------------------------------------
FORM determineServerOPSystem USING separator
                                   serverFileSystem
                                   serverOpSystem.

* Find the file system
  SELECT SINGLE fileSys
                FROM opSystem
                INTO serverFileSystem
                WHERE opSys = sy-opsys.

  FIND 'WINDOWS' IN serverFilesystem IGNORING CASE.
  IF sy-subrc = 0.
    separator = '\'.
    serverOpSystem = non_unix.
    serverFileSystem = 'Windows NT'.
  ELSE.
    FIND 'DOS' IN serverFilesystem IGNORING CASE.
    IF sy-subrc = 0.
      separator = '\'.
      serverOpSystem = non_unix.
    ELSE.
      separator = '/'.
      serverOpSystem = unix.
    ENDIF.
  ENDIF.
ENDFORM.                                                                        "determineServerOpSystem

*-------------------------------------------------------------------------------------------------------
* findExternalCommand.... Determine if the external command exists.  If it doesn't then disable the
*                         server input field
*-------------------------------------------------------------------------------------------------------
FORM findExternalCommand USING VALUE(locServerFileSystem).

  DATA: castServerOpSys TYPE syopsys.

  castServerOpSys = locServerFileSystem.

  CALL FUNCTION 'SXPG_COMMAND_CHECK'
    EXPORTING
      commandname       = 'ZDTX_MKDIR'
      operatingsystem   = castServerOpSys
    EXCEPTIONS
      command_not_found = 1
      OTHERS            = 0.

  IF sy-subrc <> 0.
    LOOP AT SCREEN.
      IF screen-name = 'PLOGICAL'.
        screen-input = 0.
        MODIFY SCREEN.
      ENDIF.

      IF screen-name = 'PSERV'.
        screen-input = 0.
        MODIFY SCREEN.
      ENDIF.

      IF screen-name = 'PPC'.
        screen-input = 0.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

    MESSAGE s000(oo) WITH 'Download to server disabled,' 'external command ZDTX_MKDIR not defined.'.
  ENDIF.
ENDFORM.

********************************************************************************************************
*****************************************DOWNLOAD ROUTINES**********************************************
********************************************************************************************************

*-------------------------------------------------------------------------------------------------------
* downloadDDStructures... download database objects to file
*-------------------------------------------------------------------------------------------------------
FORM downloadDDStructures USING iLocDictionary LIKE iDictionary[]
                                iLocDictionaryFilename LIKE iDictFilename[]
                                VALUE(pathname)
                                VALUE(HtmlFileExtension)
                                VALUE(subDir)
                                VALUE(sortTablesAsc)
                                VALUE(slashSeparator)
                                VALUE(saveToServer)
                                VALUE(displayProgressMessage)
                                VALUE(locServerFileSystem)
                                VALUE(addBackground) TYPE abap_bool.

  FIELD-SYMBOLS: <waDictionary> TYPE tDictTable.
  DATA: tableFilename TYPE string.
  DATA: tableFilenameWithPath TYPE string.
  DATA: iHtmlTable TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: newSubDirectory TYPE string.
  DATA: completeSavePath TYPE string.
  DATA: waDictFilename LIKE LINE OF iLocDictionaryFilename.

  LOOP AT iLocDictionary ASSIGNING <waDictionary>.
    PERFORM buildFilename USING pathName
                                subDir
                                <waDictionary>-tablename
                                space
                                space
                                HtmlFileExtension
                                is_table
                                saveToServer
                                slashSeparator
                                tableFilenameWithPath
                                tablefilename
                                newSubDirectory
                                completeSavePath.

    READ TABLE iLocDictionaryFilename INTO waDictFilename WITH KEY tableName = <waDictionary>-tablename
                                                                   filename = completeSavePath.
    IF sy-subrc <> 0.
*     Try and import a converted table to memory as it will be much quicker than converting it again
      IMPORT iHtmlTable FROM MEMORY ID <waDictionary>-tablename.
      IF sy-subrc <> 0.
        CONCATENATE 'Converting table' <waDictionary>-tablename 'to html' INTO statusBarMessage SEPARATED BY space.
        PERFORM displayStatus USING statusBarMessage 0.

        PERFORM convertDDtoHTML USING <waDictionary>-iStructure[]
                                      iHtmlTable[]
                                      <waDictionary>-tableName
                                      <waDictionary>-tableTitle
                                      sortTablesAsc
                                      addBackground.

        EXPORT iHtmlTable TO MEMORY ID <waDictionary>-tablename.
      ENDIF.

      IF saveToServer IS INITIAL.
        PERFORM saveFileToPc USING iHtmlTable[]
                                   tableFilenameWithPath
                                   tableFilename
                                   space
                                   space
                                   displayProgressMessage.
      ELSE.
        PERFORM saveFileToServer USING iHtmlTable[]
                                       tableFilenameWithPath
                                       tableFilename
                                       completeSavePath
                                       displayProgressMessage
                                       locServerFileSystem.
      ENDIF.

      waDictFilename-tablename = <waDictionary>-tablename.
      waDictFilename-filename = completeSavePath.
      APPEND waDictFilename TO iLocDictionaryFilename.
      CLEAR waDictFilename.
    ENDIF.

    CLEAR iHtmlTable[].
  ENDLOOP.
ENDFORM.                                                                           "downloadDDStructures

*-------------------------------------------------------------------------------------------------------
* downloadMessageClass...
*-------------------------------------------------------------------------------------------------------
FORM downloadMessageClass USING iLocMessages LIKE iMessages[]
                                VALUE(messageClassName)
                                VALUE(userFilePath)
                                VALUE(fileExtension)
                                VALUE(HTMLfileFlag)
                                      subDir
                                VALUE(customerNameRange)
                                VALUE(getIncludes)
                                VALUE(getDictStructures)
                                VALUE(userHasSelectedMessageClasses)
                                VALUE(slashSeparator)
                                VALUE(saveToServer)
                                VALUE(displayProgressMessage)
                                VALUE(locServerFileSystem)
                                VALUE(addBackground) TYPE abap_bool.

  DATA: htmlPageName TYPE string.
  DATA: newFilenameOnly TYPE string.
  DATA: newFilenameWithPath TYPE string.
  DATA: iHtmlTable TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: newSubDirectory TYPE string.
  DATA: completeSavePath TYPE string.

  PERFORM appendMessagesToFile USING iLocMessages[]
                                     iHtmlTable[]
                                     userHasSelectedMessageClasses.


  CONCATENATE `message class ` messageClassName INTO htmlPageName.

  IF htmlFileFlag IS INITIAL.
    APPEND '' TO iHtmlTable.
    APPEND  '----------------------------------------------------------------------------------' TO iHtmlTable.

    PERFORM buildFooterMessage USING iHtmlTable.
    APPEND iHtmlTable.
  ELSE.
    PERFORM convertCodeToHtml USING iHtmlTable[]
                                    htmlPageName
                                    space
                                    is_messageclass
                                    ''
                                    false
                                    fileExtension
                                    customerNameRange
                                    getIncludes
                                    getDictStructures
                                    addBackground.
  ENDIF.

  PERFORM buildFilename USING userFilePath
                              subDir
                              messageClassName
                              space
                              space
                              fileExtension
                              is_messageclass
                              saveToServer
                              slashSeparator
                              newFilenameWithPath
                              newFilenameOnly
                              newSubDirectory
                              completeSavePath.

  IF saveToServer IS INITIAL.
    PERFORM saveFileToPc USING iHtmlTable[]
                               newFilenameWithPath
                               newFilenameOnly
                               space
                               space
                               displayProgressMessage.
  ELSE.
*     Save the file to the SAP server
    PERFORM saveFileToServer USING iHtmlTable[]
                                   newFilenameWithPath
                                   newFilenameOnly
                                   completeSavePath
                                   displayProgressMessage
                                   locServerFileSystem.
  ENDIF.
ENDFORM.                                                                          "downloadMessageClass

*-------------------------------------------------------------------------------------------------------
*  appendMessagesToFile
*-------------------------------------------------------------------------------------------------------
FORM appendMessagesToFile USING iLocMessages LIKE iMessages[]
                                iLocHtml LIKE dumiHtml[]
                                VALUE(userHasSelectedMessageClasses).

  DATA: previousMessageID LIKE iMessages-arbgb.
  FIELD-SYMBOLS: <waMessage> TYPE tMessage.
  DATA: waHtml TYPE string.

  SORT iLocMessages ASCENDING BY arbgb msgnr.

  IF NOT iLocMessages[] IS INITIAL.
    IF userHasSelectedMessageClasses IS INITIAL.
*     Only add these extra lines if we are actually appending them to the end of some program code
      APPEND waHtml TO iLocHtml.
      APPEND waHtml TO iLocHtml.

      APPEND '*Messages' TO iLocHtml.
      APPEND '*----------------------------------------------------------' TO iLocHtml.
    ENDIF.

    LOOP AT iLocMessages ASSIGNING <waMessage>.
      IF ( <waMessage>-arbgb <> previousMessageID ).

        IF userHasSelectedMessageClasses IS INITIAL.
*         Only add this extra lines if we are actually appending them to the end of some program code
          APPEND '*' TO iLocHtml.
          CONCATENATE `* Message class: ` <waMessage>-arbgb INTO waHtml.
          APPEND waHtml TO iLocHtml.
        ENDIF.

        previousMessageID = <waMessage>-arbgb.
        CLEAR waHtml.
      ENDIF.

      IF userHasSelectedMessageClasses IS INITIAL.
*       Only add this extra lines if we are actually appending them to the end of some program code
        CONCATENATE '*' <waMessage>-msgnr `   ` <waMessage>-text INTO waHtml.
      ELSE.
        CONCATENATE <waMessage>-msgnr `   ` <waMessage>-text INTO waHtml.
      ENDIF.

      APPEND waHtml TO iLocHtml.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                           "appendMessagesToFile

*-------------------------------------------------------------------------------------------------------
*  downloadFunctions...       Download function modules to file.
*-------------------------------------------------------------------------------------------------------
FORM downloadFunctions USING iLocFunctions LIKE iFunctions[]
                             iLocDictionaryFilename LIKE iDictFilename[]
                             VALUE(userFilePath)
                             VALUE(fileExtension)
                             VALUE(subDir)
                             VALUE(downloadDocumentation)
                             VALUE(convertToHtml)
                             VALUE(customerNameRange)
                             VALUE(getIncludes)
                             VALUE(getDictStruct)
                             VALUE(textFileExtension)
                             VALUE(htmlFileExtension)
                             VALUE(sortTablesAsc)
                             VALUE(slashSeparator)
                             VALUE(saveToServer)
                             VALUE(displayProgressMessage)
                             VALUE(locServerFileSystem)
                             VALUE(addBackground) TYPE abap_bool.

  DATA: mainSubdir TYPE string.
  DATA: incSubdir TYPE string.
  FIELD-SYMBOLS: <waFunction> TYPE tFunction.
  FIELD-SYMBOLS: <waInclude> TYPE tInclude.
  DATA: iEmptyTextelements TYPE STANDARD TABLE OF tTextTable.
  DATA: iEmptySelectionTexts TYPE STANDARD TABLE OF tTextTable.
  DATA: iEmptyMessages TYPE STANDARD TABLE OF tMessage.
  DATA: iEmptyGuiTitles TYPE STANDARD TABLE OF tGuiTitle.
  DATA: functionDocumentationExists TYPE abap_bool VALUE false.


  LOOP AT iLocFunctions ASSIGNING <waFunction>.
    IF subDir IS INITIAL.
      incSubDir = <waFunction>-functionName.
      mainSubDir = ''.
    ELSE.
      CONCATENATE Subdir <waFunction>-functionName INTO incSubDir SEPARATED BY slashSeparator.
      mainSubDir = SubDir.
    ENDIF.

    IF NOT downloadDocumentation IS INITIAL.
      PERFORM downloadFunctionDocs USING <waFunction>-functionName
                                         <waFunction>-functionTitle
                                         userFilePath
                                         fileExtension
                                         convertToHtml
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         mainSubDir
                                         functionDocumentationExists
                                         locServerFileSystem
                                         addBackground.
    ENDIF.

*   Download main source code
    PERFORM readFunctionAndDownload USING <waFunction>-iTextelements[]
                                          <waFunction>-iSelectionTexts[]
                                          <wafunction>-iMessages[]
                                          <wafunction>-functionName
                                          <wafunction>-functionMainInclude
                                          <waFunction>-functionTitle
                                          userFilePath
                                          fileExtension
                                          mainSubDir
                                          convertToHtml
                                          functionDocumentationExists
                                          customerNameRange
                                          getIncludes
                                          getDictStruct
                                          slashSeparator
                                          saveToServer
                                          displayProgressMessage
                                          locServerFileSystem
                                          addBackground.

*   Download top include
    PERFORM readIncludeAndDownload USING iEmptyTextelements[]
                                         iEmptySelectionTexts[]
                                         iEmptyMessages[]
                                         iEmptyGuiTitles[]
                                         <waFunction>-topIncludeName
                                         <waFunction>-functionName
                                         <waFunction>-functionTitle
                                         is_function
                                         userFilePath
                                         fileExtension
                                         mainSubDir
                                         convertToHtml
                                         customerNameRange
                                         getIncludes
                                         getDictStruct
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         locServerFileSystem
                                         addBackground.

*   Download screens.
    IF NOT <waFunction>-iScreenFlow[] IS INITIAL.
      PERFORM downloadScreens USING <wafunction>-iScreenFlow[]
                                    <wafunction>-progname
                                    userFilePath
                                    textFileExtension
                                    mainSubDir
                                    slashSeparator
                                    saveToServer
                                    displayProgressMessage
                                    locServerFileSystem.
    ENDIF.

*   Download GUI titles
    IF NOT <waFunction>-iGUITitle[] IS INITIAL.
      PERFORM downloadGUITitles USING <wafunction>-iGUITitle
                                      userFilePath
                                      textFileExtension
                                      mainsubDir
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage
                                      locServerFileSystem.
    ENDIF.

*   Download all other includes
    LOOP AT <wafunction>-iIncludes ASSIGNING <waInclude>.
      PERFORM readIncludeAndDownload USING iEmptyTextelements[]
                                           iEmptySelectionTexts[]
                                           iEmptyMessages[]
                                           iEmptyGuiTitles[]
                                           <waInclude>-IncludeName
                                           space
                                           <waInclude>-IncludeTitle
                                           is_program
                                           userFilePath
                                           fileExtension
                                           incSubDir
                                           convertToHtml
                                           customerNameRange
                                           getIncludes
                                           getDictStruct
                                           slashSeparator
                                           saveToServer
                                           displayProgressMessage
                                           locServerFileSystem
                                           addBackground.

    ENDLOOP.

*   Download all dictionary structures
    IF NOT <wafunction>-iDictStruct[] IS INITIAL.
      PERFORM downloadDDStructures USING <wafunction>-iDictStruct[]
                                         iLocDictionaryFilename[]
                                         userFilePath
                                         htmlFileExtension
                                         mainSubDir
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         locServerFileSystem
                                         addBackground.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                              "downloadFunctions

*-------------------------------------------------------------------------------------------------------
*   readIcludeAndDownload...
*-------------------------------------------------------------------------------------------------------
FORM readIncludeAndDownload USING iLocTextElements LIKE dumiTextTab[]
                                  iLocSelectionTexts LIKE dumiTextTab[]
                                  iLocMessages LIKE iMessages[]
                                  iLocGUITitles LIKE dumIGUITitle[]
                                  VALUE(programName)
                                  VALUE(functionName)
                                  VALUE(programDescription)
                                  VALUE(overideProgType)
                                  VALUE(userFilePath)
                                  VALUE(fileExtension)
                                  VALUE(additionalSubDir)
                                  VALUE(convertToHtml)
                                  VALUE(customerNameRange)
                                  VALUE(getIncludes)
                                  VALUE(getDictStructures)
                                  VALUE(slashSeparator)
                                  VALUE(saveToServer)
                                  VALUE(displayProgressMessage)
                                  VALUE(locServerFileSystem)
                                  VALUE(addBackground) TYPE abap_bool.

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: localFilenameWithPath TYPE string.
  DATA: localFilenameOnly TYPE string.
  DATA: newSubdirectory TYPE string.
  DATA: objectName TYPE string.
  DATA: completeSavePath TYPE string.

  READ REPORT programName INTO iLines.

* Download GUI titles for main program
  IF NOT iLocGUITitles[] IS INITIAL.
    PERFORM appendGUITitles USING iLocGUITitles[]
                                  iLines[].
  ENDIF.

* Download text elements for main program
  IF NOT iLocTextElements[] IS INITIAL.
    PERFORM appendTextElements USING iLocTextElements[]
                                     iLines[].
  ENDIF.

* Download selection texts for main program
  IF NOT iLocSelectiontexts[] IS INITIAL.
    PERFORM appendSelectionTexts USING iLocSelectiontexts[]
                                       iLines[].
  ENDIF.

* Download messages classes for main program.
  IF NOT iLocMessages[] IS INITIAL.
    PERFORM appendMessagesToFile USING iLocMessages[]
                                       iLines[]
                                       space.
  ENDIF.

  IF convertToHtml IS INITIAL.
    APPEND '' TO iLines.
    APPEND '----------------------------------------------------------------------------------' TO iLines.
    PERFORM buildFooterMessage USING iLines.
    APPEND iLines.
  ELSE.
    PERFORM convertCodeToHtml USING iLines[]
                                    programName
                                    programDescription
                                    overideProgType
                                    space
                                    space
                                    fileExtension
                                    customerNameRange
                                    getIncludes
                                    getDictStructures
                                    addBackground.
  ENDIF.

  IF functionName IS INITIAL.
    objectName = programName.
  ELSE.
    objectName = functionName.
  ENDIF.

  PERFORM buildFilename USING userFilePath
                              additionalSubDir
                              objectName
                              space
                              programName
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  IF saveToServer IS INITIAL.
    PERFORM saveFileToPc USING iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  ELSE.
    PERFORM saveFileToServer USING iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage
                                   locServerFileSystem.
  ENDIF.
ENDFORM.                                                                         "readIncludeAndDownload

*-------------------------------------------------------------------------------------------------------
*   readClassAndDownload...
*-------------------------------------------------------------------------------------------------------
FORM readClassAndDownload USING waLocClass TYPE tClass
                                VALUE(className)
                                VALUE(functionName)
                                VALUE(overideProgType)
                                VALUE(userFilePath)
                                VALUE(fileExtension)
                                VALUE(additionalSubDir)
                                VALUE(convertToHtml)
                                VALUE(customerNameRange)
                                VALUE(getIncludes)
                                VALUE(getDictStructures)
                                VALUE(slashSeparator)
                                VALUE(saveToServer)
                                VALUE(displayProgressMessage)
                                VALUE(locServerFileSystem)
                                VALUE(addBackground) TYPE abap_bool.

  DATA: iTempLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: localFilenameWithPath TYPE string.
  DATA: localFilenameOnly TYPE string.
  DATA: newSubdirectory TYPE string.
  DATA: objectName TYPE string.
  DATA: castClassName TYPE program.
  DATA: completeSavePath TYPE string.

* Build up attribute comments
  APPEND '**************************************************************************' TO iLines.
  APPEND '*   Class attributes.                                                    *' TO iLines.
  APPEND '**************************************************************************' TO iLines.
  CASE waLocClass-exposure.
    WHEN 0.
      APPEND `Instantiation: Private` TO iLines.
    WHEN 1.
      APPEND `Instantiation: Protected` TO iLines.
    WHEN 2.
      APPEND `Instantiation: Public` TO iLines.
  ENDCASE.
  CONCATENATE `Message class: ` waLocClass-msg_id INTO iLines.
  APPEND iLines.
  CASE waLocClass-state.
    WHEN 0.
      APPEND `State: Only Modelled` TO iLines.
    WHEN 1.
      APPEND `State: Implemented` TO iLines.
  ENDCASE.
  CONCATENATE `Final Indicator: ` waLocClass-clsfinal INTO iLines.
  APPEND iLines.
  CONCATENATE `R/3 Release: ` waLocClass-r3Release INTO iLines.
  APPEND iLines.
  CLEAR iLines.
  APPEND iLines.

  castClassName = waLocClass-publicClassKey.
  READ REPORT castClassName INTO iTempLines.
  IF sy-subrc = 0.
    PERFORM reFormatClassCode USING iTempLines[].

    APPEND '**************************************************************************' TO iLines.
    APPEND '*   Public section of class.                                             *' TO iLines.
    APPEND '**************************************************************************' TO iLines.
    LOOP AT iTempLines.
      APPEND iTempLines TO iLines.
    ENDLOOP.
  ENDIF.

  castClassName = waLocClass-privateClassKey.
  READ REPORT castClassName INTO iTempLines.
  IF sy-subrc = 0.
    PERFORM reFormatClassCode USING iTempLines[].

    APPEND iLines.
    APPEND '**************************************************************************' TO iLines.
    APPEND '*   Private section of class.                                            *' TO iLines.
    APPEND '**************************************************************************' TO iLines.
    LOOP AT iTempLines.
      APPEND iTempLines TO iLines.
    ENDLOOP.
  ENDIF.

  castClassName = waLocClass-ProtectedClassKey.
  READ REPORT castClassName INTO iTempLines.
  IF sy-subrc = 0.
    PERFORM reFormatClassCode USING iTempLines[].

    APPEND iLines.
    APPEND '**************************************************************************' TO iLines.
    APPEND '*   Protected section of class.                                          *' TO iLines.
    APPEND '**************************************************************************' TO iLines.
    LOOP AT iTempLines.
      APPEND iTempLines TO iLines.
    ENDLOOP.
  ENDIF.

  castClassName = waLocClass-typesClassKey.
  READ REPORT castClassName INTO iTempLines.
  IF sy-subrc = 0.
    APPEND iLines.
    APPEND '**************************************************************************' TO iLines.
    APPEND '*   Types section of class.                                              *' TO iLines.
    APPEND '**************************************************************************' TO iLines.
    LOOP AT iTempLines.
      APPEND iTempLines TO iLines.
    ENDLOOP.
  ENDIF.

* Download text elements for this class
  IF NOT waLocClass-iTextElements[] IS INITIAL.
    PERFORM appendTextElements USING waLocClass-iTextElements[]
                                     iLines[].
  ENDIF.

* Download messages classes for this class.
  IF NOT waLocClass-iMessages[] IS INITIAL.
    PERFORM appendMessagesToFile USING waLocClass-iMessages[]
                                       iLines[]
                                       space.
  ENDIF.

* Download exception texts for this class
  IF NOT waLocClass-iConcepts[] IS INITIAL.
    PERFORM appendExceptionTexts USING waLocClass-iConcepts[]
                                       iLines[].
  ENDIF.


  IF convertToHtml IS INITIAL.
    APPEND '' TO iLines.
    APPEND '----------------------------------------------------------------------------------' TO iLines.
    PERFORM buildFooterMessage USING iLines.
    APPEND iLines.
  ELSE.
    PERFORM convertClassToHtml USING iLines[]
                                    className
                                    waLocClass-descript
                                    overideProgType
                                    fileExtension
                                    customerNameRange
                                    getDictStructures
                                    addBackground.
  ENDIF.

  IF functionName IS INITIAL.
    objectName = className.
  ELSE.
    objectName = functionName.
  ENDIF.

  PERFORM buildFilename USING userFilePath
                              additionalSubDir
                              objectName
                              space
                              className
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  IF saveToServer IS INITIAL.
    PERFORM saveFileToPc USING iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  ELSE.
    PERFORM saveFileToServer USING iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage
                                   locServerFileSystem.
  ENDIF.
ENDFORM.                                                                           "readClassAndDownload

*-------------------------------------------------------------------------------------------------------
*   readMethodAndDownload...
*-------------------------------------------------------------------------------------------------------
FORM readMethodAndDownload USING waLocMethod TYPE tMethod
                                VALUE(methodName)
                                VALUE(methodKey)
                                VALUE(functionName)
                                VALUE(overideProgType)
                                VALUE(userFilePath)
                                VALUE(fileExtension)
                                VALUE(additionalSubDir)
                                VALUE(convertToHtml)
                                VALUE(customerNameRange)
                                VALUE(getIncludes)
                                VALUE(getDictStructures)
                                VALUE(slashSeparator)
                                VALUE(saveToServer)
                                VALUE(displayProgressMessage)
                                VALUE(locServerFileSystem)
                                VALUE(addBackground) TYPE abap_bool.

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iTempLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: localFilenameWithPath TYPE string.
  DATA: localFilenameOnly TYPE string.
  DATA: newSubdirectory TYPE string.
  DATA: objectName TYPE string.
  DATA: castMethodKey TYPE program.
  DATA: completeSavePath TYPE string.

* Add the method scope to the downloaded file
  APPEND '**************************************************************************' TO iLines.
  APPEND '*   Method attributes.                                                   *' TO iLines.
  APPEND '**************************************************************************' TO iLines.
  CASE waLocMethod-exposure.
    WHEN 0.
      APPEND `Instantiation: Private` TO iLines.
    WHEN 1.
      APPEND `Instantiation: Protected` TO iLines.
    WHEN 2.
      APPEND `Instantiation: Public` TO iLines.
  ENDCASE.
  APPEND '**************************************************************************' TO iLines.
  APPEND '' TO iLines.

  castMethodKey = waLocMethod-methodKey.
  READ REPORT castMethodKey INTO iTempLines.
  LOOP AT iTempLines.
    APPEND iTempLines TO iLines.
  ENDLOOP.

  IF convertToHtml IS INITIAL.
    APPEND '' TO iLines.
    APPEND '----------------------------------------------------------------------------------' TO iLines.
    PERFORM buildFooterMessage USING iLines.
    APPEND iLines.
  ELSE.
    PERFORM convertCodeToHtml USING iLines[]
                                    methodName
                                    waLocMethod-descript
                                    overideProgType
                                    space
                                    space
                                    fileExtension
                                    customerNameRange
                                    getIncludes
                                    getDictStructures
                                    addBackground.
  ENDIF.

  IF functionName IS INITIAL.
    objectName = methodName.
  ELSE.
    objectName = functionName.
  ENDIF.

  CASE waLocMethod-exposure.
    WHEN 0.
*     Private
      CONCATENATE additionalSubDir slashSeparator 'private_methods' INTO additionalSubDir.
    WHEN 1.
*     Protected
      CONCATENATE additionalSubDir slashSeparator 'protected_methods' INTO additionalSubDir.
    WHEN 2.
*     Public
      CONCATENATE additionalSubDir slashSeparator 'public_methods' INTO additionalSubDir.
  ENDCASE.

  PERFORM buildFilename USING userFilePath
                              additionalSubDir
                              objectName
                              space
                              methodName
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  IF saveToServer IS INITIAL.
    PERFORM saveFileToPc USING iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  ELSE.
    PERFORM saveFileToServer USING iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage
                                   locServerFileSystem.
  ENDIF.
ENDFORM.                                                                          "readMethodAndDownload

*-------------------------------------------------------------------------------------------------------
*   readFunctionAndDownload...
*-------------------------------------------------------------------------------------------------------
FORM readFunctionAndDownload USING iLocTextElements LIKE dumiTextTab[]
                                   iLocSelectionTexts LIKE dumiTextTab[]
                                   iLocMessages LIKE iMessages[]
                                   VALUE(functionName)
                                   VALUE(functionInternalName)
                                   VALUE(shortText)
                                   VALUE(userFilePath)
                                   VALUE(fileExtension)
                                   VALUE(subDir)
                                   VALUE(convertToHtml)
                                   VALUE(functionDocumentationExists)
                                   VALUE(customerNameRange)
                                   VALUE(getIncludes)
                                   VALUE(getDictStructures)
                                   VALUE(slashSeparator)
                                   VALUE(saveToServer)
                                   VALUE(displayProgressMessage)
                                   VALUE(locServerFileSystem)
                                   VALUE(addBackground) TYPE abap_bool.

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: localFilenameWithPath TYPE string.
  DATA: localFilenameOnly TYPE string.
  DATA: newSubDirectory TYPE string.
  DATA: completeSavePath TYPE string.

  READ REPORT functionInternalName INTO iLines.

* If we found any text elements for this function then we ought to append them to the main include.
  IF NOT iLocTextElements[] IS INITIAL.
    PERFORM appendTextElements USING iLocTextElements[]
                                     iLines[].
  ENDIF.

* If we found any message classes for this function then we ought to append them to the main include.
  IF NOT iLocMessages[] IS INITIAL.
    PERFORM appendMessagesToFile USING iLocMessages[]
                                       iLines[]
                                       space.
  ENDIF.

  IF convertToHtml IS INITIAL.
    APPEND '' TO iLines.
    APPEND '----------------------------------------------------------------------------------' TO iLines.
    PERFORM buildFooterMessage USING iLines.
    APPEND iLines.
  ELSE.
    PERFORM convertFunctionToHtml USING iLines[]
                                        functionName
                                        shortText
                                        is_function
                                        functionDocumentationExists
                                        true
                                        fileExtension
                                        customerNameRange
                                        getIncludes
                                        getDictStructures
                                        addBackground.
  ENDIF.

  PERFORM buildFilename USING userFilePath
                              subDir
                              functionName
                              space
                              space
                              fileExtension
                              is_function
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubDirectory
                              completeSavePath.

  IF saveToServer IS INITIAL.
    PERFORM saveFileToPc USING iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  ELSE.
    PERFORM saveFileToServer USING iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage
                                   locServerFileSystem.
  ENDIF.
ENDFORM.                                                                        "readFunctionAndDownload

*-------------------------------------------------------------------------------------------------------
*  buildFilename...
*-------------------------------------------------------------------------------------------------------
FORM buildFilename USING VALUE(userPath)
                         VALUE(additionalSubDirectory)
                         VALUE(objectName)
                         VALUE(mainFunctionNo)
                         VALUE(includeName)
                         VALUE(fileExtension)
                         VALUE(downloadType)
                         VALUE(downloadToServer)
                         VALUE(slashSeparator)
                               newFilenameWithPath
                               newFilenameOnly
                               newSubDirectory
                               completePath.

* If we are running on a non UNIX environment we will need to remove forward slashes from the additional path.
  IF downloadToServer IS INITIAL.
    IF frontendOpSystem = non_unix.
      IF NOT additionalSubdirectory IS INITIAL.
        TRANSLATE additionalSubdirectory USING '/_'.
        IF additionalSubdirectory+0(1) = '_'.
          SHIFT additionalSubdirectory LEFT BY 1 PLACES.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
    IF serverOpSystem = non_unix.
      IF NOT additionalSubdirectory IS INITIAL.
        TRANSLATE additionalSubdirectory USING '/_'.
        IF additionalSubdirectory+0(1) = '_'.
          SHIFT additionalSubdirectory LEFT BY 1 PLACES.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

  CASE downloadType.
*   Programs
    WHEN is_program.
      IF additionalSubDirectory IS INITIAL.
        CONCATENATE userPath slashSeparator objectName period fileExtension INTO newFilenameWithPath.
        CONCATENATE userPath slashSeparator INTO completePath.
      ELSE.
        CONCATENATE userPath slashSeparator additionalSubdirectory
                             slashSeparator objectName period fileExtension INTO newFilenameWithPath.
        CONCATENATE userPath slashSeparator additionalSubdirectory INTO completePath.
      ENDIF.

*   Function Modules
    WHEN is_function.
      IF additionalSubdirectory IS INITIAL.
        FIND 'top' IN includeName IGNORING CASE.
        IF sy-subrc = 0.
          CONCATENATE userPath slashSeparator objectName
                               slashSeparator 'Global-' objectName
                               period fileExtension
                               INTO newFilenameWithPath.
        ELSE.
          IF includeName CS mainFunctionNo AND NOT mainFunctionNo IS INITIAL.
            CONCATENATE userPath slashSeparator objectName
                                 slashSeparator objectName
                                 period fileExtension
                                 INTO newFilenameWithPath.
          ELSE.
            CONCATENATE userPath slashSeparator objectName
                                 slashSeparator objectName
                                 period fileExtension
                                 INTO newFilenameWithPath.
          ENDIF.
        ENDIF.
        newSubDirectory = objectName.
        CONCATENATE userPath
                    slashSeparator
                    newSubDirectory
                    slashSeparator INTO completePath.
      ELSE.
        FIND 'top' IN includeName IGNORING CASE.
        IF sy-subrc = 0.
          CONCATENATE userPath slashSeparator additionalSubdirectory
                               slashSeparator objectName
                               slashSeparator 'Global-' objectName
                               period fileExtension
                               INTO newFilenameWithPath.
        ELSE.
          IF includeName CS mainFunctionNo AND NOT mainFunctionNo IS INITIAL.
            CONCATENATE userPath slashSeparator additionalSubdirectory
                                 slashSeparator objectName
                                 slashSeparator objectName
                                 period fileExtension
                                 INTO newFilenameWithPath.
          ELSE.
            CONCATENATE userPath slashSeparator additionalSubdirectory
                                 slashSeparator objectName
                                 slashSeparator objectName
                                 period fileExtension
                                 INTO newFilenameWithPath.
          ENDIF.
        ENDIF.
        CONCATENATE additionalSubDirectory slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubdirectory slashSeparator objectName INTO completePath.
      ENDIF.

*   Table definition
    WHEN is_table.
      IF additionalSubdirectory IS INITIAL.
        CONCATENATE userPath slashSeparator 'Dictionary_Objects'   " slashSeparator objectName
                             slashSeparator
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator objectName INTO NewSubDirectory.
        CONCATENATE userPath slashSeparator objectName INTO completePath.
      ELSE.
        CONCATENATE userpath slashSeparator additionalSubDirectory
                             slashSeparator 'Dictionary_Objects'   " slashSeparator objectName
                             slashSeparator
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator objectName INTO completePath.
      ENDIF.

*   Program & Function documentation
    WHEN is_documentation.
      IF additionalSubDirectory IS INITIAL.
        CONCATENATE userPath slashSeparator objectName
                             slashSeparator 'Docs-'
                             objectName period
                             fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator objectName INTO completePath.
      ELSE.
        CONCATENATE userPath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Docs-'
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userpath slashSeparator additionalSubDirectory slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userpath slashSeparator additionalSubDirectory slashSeparator objectName INTO completePath.
      ENDIF.

*   Screens
    WHEN is_screen.
      IF additionalSubDirectory IS INITIAL.
        CONCATENATE userpath slashSeparator 'Screens'
                             slashSeparator 'screen_'
                             objectName period
                             fileExtension INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator 'screens' INTO newSubDirectory.
        CONCATENATE userPath slashSeparator 'screens' INTO completePath.

      ELSE.
        CONCATENATE userpath slashSeparator additionalSubdirectory
                             slashSeparator 'Screens'
                             slashSeparator 'screen_'
                             objectName period
                             fileExtension INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator 'screens' INTO newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator 'screens' INTO completePath.
      ENDIF.

*   GUI title
    WHEN is_guititle.
      IF additionalSubDirectory IS INITIAL.
        CONCATENATE userpath slashSeparator 'Screens'
                             slashSeparator 'gui_title_'
                             objectName period
                             fileExtension INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator 'screens' INTO newSubDirectory.
        CONCATENATE userPath slashSeparator 'screens' INTO completePath.
      ELSE.
        CONCATENATE userpath slashSeparator additionalSubdirectory
                             slashSeparator 'Screens'
                             slashSeparator 'gui_title_'
                             objectName period
                             fileExtension INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator 'Screens' INTO newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator 'Screens' INTO completePath.
      ENDIF.

*   Message Class
    WHEN is_messageclass.
      IF additionalSubDirectory IS INITIAL.
        CONCATENATE userPath slashSeparator objectName
                             slashSeparator 'Message class-'
                             objectName period
                             fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator objectName INTO completePath.
      ELSE.
        CONCATENATE userPath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Message class-'
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userpath slashSeparator additionalSubDirectory slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userpath slashSeparator additionalSubDirectory slashSeparator objectName INTO completePath.
      ENDIF.

*   Class definition
    WHEN is_class.
      IF additionalSubdirectory IS INITIAL.
        CONCATENATE userPath slashSeparator objectName
                             slashSeparator 'Class-'
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator objectName INTO completePath.
      ELSE.
        CONCATENATE userpath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Class-'
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubDirectory slashSeparator objectName INTO completePath.
      ENDIF.

*   Class definition
    WHEN is_method.
      IF additionalSubdirectory IS INITIAL.
        CONCATENATE userPath slashSeparator
                             objectName period fileExtension
                             INTO newFilenameWithPath.

        CONCATENATE userPath slashSeparator objectName INTO newSubDirectory.
        CONCATENATE userPath slashSeparator objectName INTO completePath.
      ELSE.
        CONCATENATE userpath slashSeparator additionalSubDirectory
                             slashSeparator
                             objectName period fileExtension
                             INTO newFilenameWithPath.

*        concatenate userPath slashSeparator additionalSubDirectory slashSeparator objectName into newSubDirectory.
        CONCATENATE userPath slashSeparator additionalSubDirectory INTO completePath.
      ENDIF.
  ENDCASE.

  TRANSLATE completePath TO LOWER CASE.
  CONCATENATE objectName period fileExtension INTO newFilenameOnly.
  TRANSLATE newFilenameOnly TO LOWER CASE.
  TRANSLATE newFilenameWithPath TO LOWER CASE.
  TRANSLATE newSubDirectory TO LOWER CASE.

* If we are running on a non UNIX environment we will need to remove incorrect characters from the filename.
  IF downloadToServer IS INITIAL.
    IF frontendOpSystem = non_unix.
      TRANSLATE newFilenameOnly USING '/_'.
      TRANSLATE newFilenameWithPath USING '/_'.
      TRANSLATE newFilenameOnly USING '< '.
      TRANSLATE newFilenameWithPath USING '< '.
      TRANSLATE newFilenameOnly USING '> '.
      TRANSLATE newFilenameWithPath USING '> '.
      TRANSLATE newFilenameOnly USING '? '.
      TRANSLATE newFilenameWithPath USING '? '.
      TRANSLATE newFilenameOnly USING '| '.
      TRANSLATE newFilenameWithPath USING '| '.
      CONDENSE newFilenameOnly NO-GAPS.
      CONDENSE newFilenameWithPath NO-GAPS.
    ENDIF.
  ELSE.
    IF serverOpSystem = non_unix.
      TRANSLATE newFilenameOnly USING '/_'.
      TRANSLATE newFilenameWithPath USING '/_'.
      TRANSLATE newFilenameOnly USING '< '.
      TRANSLATE newFilenameWithPath USING '< '.
      TRANSLATE newFilenameOnly USING '> '.
      TRANSLATE newFilenameWithPath USING '> '.
      TRANSLATE newFilenameOnly USING '? '.
      TRANSLATE newFilenameWithPath USING '? '.
      TRANSLATE newFilenameOnly USING '| '.
      TRANSLATE newFilenameWithPath USING '| '.
      CONDENSE newFilenameOnly NO-GAPS.
      CONDENSE newFilenameWithPath NO-GAPS.
    ENDIF.
  ENDIF.
ENDFORM.                                                                                 "buildFilename

*-------------------------------------------------------------------------------------------------------
*  saveFileToPc...    write an internal table to a file on the local PC
*-------------------------------------------------------------------------------------------------------
FORM saveFileToPc USING iDownload TYPE STANDARD TABLE
                        VALUE(filenameWithPath)
                        VALUE(filename)
                        VALUE(writeFieldSeparator)
                        VALUE(truncateTrailingBlanks)
                        VALUE(displayProgressMessage).

  DATA: statusMessage TYPE string.
  DATA: objFile TYPE REF TO cl_gui_frontend_services.
  DATA: strSubrc TYPE string.

  IF NOT displayProgressMessage IS INITIAL.
    CONCATENATE `Downloading: ` filename INTO statusMessage.
    PERFORM displayStatus USING statusMessage 0.
  ENDIF.

  CREATE OBJECT objFile.
  objFile->gui_download( EXPORTING filename = filenameWithPath
                                    filetype = 'ASC'
                                    write_field_separator = writeFieldSeparator
                                    trunc_trailing_blanks = truncateTrailingBlanks
                           CHANGING data_tab = iDownload[]
                         EXCEPTIONS file_write_error        = 1
                                    no_batch                = 2
                                    gui_refuse_filetransfer = 3
                                    invalid_type            = 4
                                    no_authority            = 5
                                    unknown_error           = 6
                                    header_not_allowed      = 7
                                    separator_not_allowed   = 8
                                    filesize_not_allowed    = 9
                                    header_too_long         = 10
                                    dp_error_create         = 11
                                    dp_error_send           = 12
                                    dp_error_write          = 13
                                    unknown_dp_error        = 14
                                    access_denied           = 15
                                    dp_out_of_memory        = 16
                                    disk_full               = 17
                                    dp_timeout              = 18
                                    file_not_found          = 19
                                    dataprovider_exception  = 20
                                    control_flush_error     = 21
                                    not_supported_by_gui    = 22
                                    error_no_gui            = 23 ).

  IF sy-subrc <> 0.
    strSubrc = sy-subrc.
    CONCATENATE `File save error: ` filename ` sy-subrc: ` strSubrc INTO statusMessage.
    PERFORM displayStatus USING statusMessage 3.
  ENDIF.
ENDFORM.                                                                                                  "saveFileToPc

*----------------------------------------------------------------------------------------------------------------------
*  saveFileToServer...    write an internal table to a file on the SAP server
*----------------------------------------------------------------------------------------------------------------------
FORM saveFileToServer USING iDownload TYPE STANDARD TABLE
                            VALUE(filenameWithPath)
                            VALUE(filename)
                            VALUE(path)
                            VALUE(displayProgressMessage)
                             VALUE(locServerFileSystem).

  DATA: waDownload TYPE string.
  DATA: statusMessage TYPE string.

  IF NOT displayProgressMessage IS INITIAL.
    CONCATENATE `Downloading: ` filename INTO statusMessage.
    PERFORM displayStatus USING statusMessage 0.
  ENDIF.

  READ TABLE iServerPaths WITH KEY table_line = path.
  IF sy-subrc <> 0.
    PERFORM createServerDirectory USING path locServerFileSystem.
    APPEND path TO iServerPaths.
  ENDIF.

  OPEN DATASET filenameWithPath FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
  IF sy-subrc = 0.
    LOOP AT iDownload INTO waDownload.
      TRANSFER waDownload TO filenameWithPath.
      IF sy-subrc <> 0.
        MESSAGE e000(oo) WITH 'Error transferring data to file'.
      ENDIF.
    ENDLOOP.

    CLOSE DATASET filenameWithPath.
    IF sy-subrc <> 0.
      MESSAGE e000(oo) WITH 'Error closing file'.
    ENDIF.
  ELSE.
*   Unable to create a file
    MESSAGE e000(oo) WITH 'Error creating file on SAP server' 'check permissions'.
  ENDIF.
ENDFORM.                                                                                              "saveFileToServer

*----------------------------------------------------------------------------------------------------------------------
* createServerDirectory...
*----------------------------------------------------------------------------------------------------------------------
FORM createServerDirectory USING VALUE(path)
                                 VALUE(locServerFileSystem).

  DATA: castServerOpSys TYPE syopsys.

  castServerOpSys = locServerFileSystem.

*  Parameters for remove command.
  DATA: param1 TYPE sxpgcolist-parameters.
*  Return status
  DATA: funcStatus TYPE extcmdexex-status.
*  Command line listing returned by the function
  DATA: iServerOutput TYPE STANDARD TABLE OF btcxpm.
  DATA: waServeroutput TYPE btcxpm.
*  Targetsystem type conversion variable.
  DATA: target TYPE rfcdisplay-rfchost.
* Operating system
  DATA: operatingSystem TYPE sxpgcolist-opsystem.
*  Head for split command.
  DATA: head TYPE string..
  DATA: tail TYPE string.

  param1 = path.
  target = sy-host.
  operatingSystem = locServerFileSystem.

  CALL FUNCTION 'SXPG_COMMAND_EXECUTE'
    EXPORTING
      commandname                   = 'ZDTX_MKDIR'
      additional_parameters         = param1
      operatingsystem               = castServerOpSys
      targetsystem                  = target
      stdout                        = 'X'
      stderr                        = 'X'
      terminationwait               = 'X'
    IMPORTING
      status                        = funcStatus
    TABLES
      exec_protocol                 = iServerOutput[]
    EXCEPTIONS
      no_permission                 = 1
      command_not_found             = 2
      parameters_too_long           = 3
      security_risk                 = 4
      wrong_check_call_interface    = 5
      program_start_error           = 6
      program_termination_error     = 7
      x_error                       = 8
      parameter_expected            = 9
      too_many_parameters           = 10
      illegal_command               = 11
      wrong_asynchronous_parameters = 12
      cant_enq_tbtco_entry          = 13
      jobcount_generation_error     = 14
      OTHERS                        = 15.

  IF sy-subrc = 0.
*   Although the function succeded did the external command actually work
    IF funcStatus = 'E'.
*     External command returned with an error
      IF sy-opsys CS 'Windows NT'.
        READ TABLE iServeroutput INDEX 1 INTO waServeroutput.
        IF waServeroutput-message NS 'already exists'.
*         An error occurred creating the directory on the server
          MESSAGE e000(oo) WITH 'An error occurred creating a directory'.
        ENDIF.
      ELSE.
        READ TABLE iServerOutput INDEX 2 INTO waServeroutput.
        SPLIT waServeroutput-message AT space INTO head tail.
        SHIFT tail LEFT DELETING LEADING space.
        IF tail <> 'Do not specify an existing file.'.
*         An error occurred creating the directory on the server
          MESSAGE e000(oo) WITH 'An error occurred creating a directory'.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
    CASE sy-subrc.
      WHEN 1.
*       No permissions to run the command
        MESSAGE e000(oo) WITH 'No permissions to run external command ZDTX_MKDIR'.
      WHEN 2.
*       External command not found
        MESSAGE e000(oo) WITH 'External comand ZDTX_MKDIR not found'.

      WHEN OTHERS.
*       Unable to create the directory
        MESSAGE e000(oo) WITH 'An error occurred creating a directory'
                              ', subrc:'
                              sy-subrc.
    ENDCASE.
  ENDIF.
ENDFORM.                                                                                         "createServerDirectory

*----------------------------------------------------------------------------------------------------------------------
* appendTextElements...
*----------------------------------------------------------------------------------------------------------------------
FORM appendTextElements USING iLocTextElements LIKE dumiTextTab[]
                              iLocLines LIKE dumiHtml[].

  FIELD-SYMBOLS: <waTextElement> TYPE tTextTable.
  DATA: waLine TYPE string.

  IF lines( iLocTextElements ) > 0.
    APPEND '' TO iLocLines.

    APPEND '*Text elements' TO iLocLines.
    APPEND '*----------------------------------------------------------' TO  iLocLines.
    LOOP AT iLocTextElements ASSIGNING <waTextElement>.
      CONCATENATE '*  ' <waTextElement>-key <waTextElement>-entry INTO waLine SEPARATED BY space.
      APPEND waLine TO iLocLines.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                            "appendTextElements

*----------------------------------------------------------------------------------------------------------------------
* appendGUITitles...
*----------------------------------------------------------------------------------------------------------------------
FORM appendGUITitles USING iLocGUItitles LIKE dumiGUITitle[]
                           iLocLines LIKE dumiHtml[].

  FIELD-SYMBOLS: <waGUITitle> TYPE tGUITitle.
  DATA: waLine TYPE string.

  IF lines( iLocGUItitles ) > 0.
    APPEND '' TO iLocLines.

    APPEND '*GUI Texts' TO iLocLines.
    APPEND '*----------------------------------------------------------' TO  iLocLines.
    LOOP AT iLocGUItitles ASSIGNING <waGUItitle>.
      CONCATENATE '*  ' <waGUItitle>-obj_code '-->' <waGUItitle>-text INTO waLine SEPARATED BY space.
      APPEND waLine TO iLocLines.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                               "appendGUITitles

*----------------------------------------------------------------------------------------------------------------------
* appendSelectionTexts...
*----------------------------------------------------------------------------------------------------------------------
FORM appendSelectionTexts USING iLocSelectionTexts LIKE dumiTextTab[]
                                iLocLines LIKE dumiHtml[].

  FIELD-SYMBOLS: <waSelectionText> TYPE tTextTable.
  DATA: waLine TYPE string.

  IF lines( iLocSelectionTexts ) > 0.
    APPEND '' TO iLocLines.
    APPEND '' TO iLocLines.

    APPEND '*Selection texts' TO iLocLines.
    APPEND '*----------------------------------------------------------' TO  iLocLines.
    LOOP AT iLocSelectiontexts ASSIGNING <waSelectionText>.
      CONCATENATE '*  ' <waSelectionText>-key <waSelectionText>-entry INTO waLine SEPARATED BY space.
      APPEND waLine TO iLocLines.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                          "appendSelectionTexts

*----------------------------------------------------------------------------------------------------------------------
* appendExceptionTexts...
*----------------------------------------------------------------------------------------------------------------------
FORM appendExceptionTexts USING iConcepts LIKE dumiConcepts[]
                                iLocLines LIKE dumiHtml[].

  FIELD-SYMBOLS: <waConcept> TYPE tConcept.
  DATA: waLine TYPE string.
  DATA: conceptText TYPE sotr_txt.

  IF lines( iConcepts ) > 0.
    APPEND '' TO iLocLines.

    APPEND '*Exception texts' TO iLocLines.
    APPEND '*----------------------------------------------------------' TO  iLocLines.
    LOOP AT iConcepts ASSIGNING <waConcept>.
*     Find the text for this concept
      CALL FUNCTION 'SOTR_GET_TEXT_KEY'
        EXPORTING
          concept                = <waConcept>-concept
          langu                  = pMLang
          search_in_second_langu = 'X'
*         second_langu           = 'DE'
        IMPORTING
          e_text                 = conceptText
        EXCEPTIONS
          no_entry_found         = 1
          parameter_error        = 2
          OTHERS                 = 3.

      IF sy-subrc = 0.
        CONCATENATE '*  ' <waConcept>-constName '-' conceptText  INTO waLine SEPARATED BY space.
        APPEND waLine TO iLocLines.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                                                                                          "appendExceptionTexts

*----------------------------------------------------------------------------------------------------------------------
* downloadFunctionDocs...
*----------------------------------------------------------------------------------------------------------------------
FORM downloadFunctionDocs USING VALUE(functionName)
                                VALUE(functionDescription)
                                VALUE(userFilePath)
                                VALUE(fileExtension)
                                VALUE(convertToHtml)
                                VALUE(slashSeparator)
                                VALUE(saveToServer)
                                VALUE(displayProgressMessage)
                                      subDir
                                      documentationDownloaded
                                VALUE(locServerFileSystem)
                                VALUE(addBackground) TYPE abap_bool.

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iDocumentation TYPE STANDARD TABLE OF funct WITH HEADER LINE.
  DATA: iExceptions TYPE STANDARD TABLE OF rsexc WITH HEADER LINE.
  DATA: iExport TYPE STANDARD TABLE OF rsexp WITH HEADER LINE.
  DATA: iParameter TYPE STANDARD TABLE OF rsimp WITH HEADER LINE.
  DATA: iTables TYPE STANDARD TABLE OF rstbl WITH HEADER LINE.
  DATA: iScriptLines TYPE STANDARD TABLE OF tline WITH HEADER LINE.
  DATA: htmlPageName TYPE string.
  DATA: newFilenameWithPath TYPE string.
  DATA: newFilenameOnly TYPE string.
  DATA: object LIKE dokhl-object.
  DATA: stringLength TYPE i VALUE 0.
  DATA: newSubDirectory TYPE string.
  DATA: waLine(255).
  DATA: completeSavePath TYPE string.

  documentationDownloaded = false.
  object = functionName.

  CALL FUNCTION 'FUNCTION_IMPORT_DOKU'
    EXPORTING
      funcName           = functionName
    TABLES
      dokumentation      = iDocumentation
      exception_list     = iExceptions
      export_parameter   = iExport
      import_parameter   = iParameter
      tables_parameter   = iTables
    EXCEPTIONS
      error_message      = 1
      function_not_found = 2
      invalid_name       = 3
      OTHERS             = 4.

  CALL FUNCTION 'DOCU_GET'
    EXPORTING
      id                     = 'FU'
      langu                  = pMLang
      object                 = object
      typ                    = 'T'
      version_active_or_last = 'L'
    TABLES
      line                   = iScriptLines
    EXCEPTIONS
      no_docu_on_screen      = 1
      no_docu_self_def       = 2
      no_docu_temp           = 3
      ret_code               = 4
      OTHERS                 = 5.

  IF sy-subrc = 0 AND NOT ( iScriptLines[] IS INITIAL ).
    APPEND 'SHORT TEXT' TO iLines.
    CONCATENATE space functionDescription INTO functionDescription SEPARATED BY space.
    APPEND functionDescription TO iLines.
    APPEND space TO iLines.
    LOOP AT iScriptLines.
      MOVE iScriptLines-tdline TO iLines.
      CONCATENATE space iLines INTO iLines SEPARATED BY space.
      WHILE iLines CP '&*' OR iLines CP '*&'.
        REPLACE '&' INTO iLines WITH space.
        SHIFT iLines LEFT DELETING LEADING space.
      ENDWHILE.
      APPEND iLines.
    ENDLOOP.

    CLEAR iLines.
    IF NOT ( iDocumentation[] IS INITIAL ).
      APPEND iLines.
      APPEND 'PARAMETER DOCUMENTATION' TO iLines.
      APPEND '-----------------------' TO iLines.
      APPEND iLines.

      DESCRIBE FIELD iDocumentation-parameter LENGTH stringLength IN CHARACTER MODE.
      stringLength = stringLength + 3.
      LOOP AT iDocumentation.
        MOVE iDocumentation-parameter TO waLine.
        MOVE iDocumentation-stext TO waLine+stringLength.
        APPEND waLine TO iLines.
      ENDLOOP.
    ENDIF.

    CONCATENATE `Documentation - ` functionName INTO htmlPageName.

    IF convertToHtml IS INITIAL.
      APPEND iLines.
      APPEND  '----------------------------------------------------------------------------------' TO iLines.
      APPEND iLines.
      PERFORM buildFooterMessage USING iLines.
      APPEND iLines.
    ELSE.
      PERFORM convertCodeToHtml USING iLines[]
                                      htmlPageName
                                      space
                                      is_documentation
                                      true
                                      space
                                      space
                                      space
                                      space
                                      space
                                      addBackground.
    ENDIF.

    PERFORM buildFilename USING userFilePath
                                subDir
                                functionName
                                space
                                space
                                fileExtension
                                is_documentation
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newFilenameOnly
                                newSubDirectory
                                completeSavePath.

    IF saveToServer IS INITIAL.
      PERFORM saveFileToPC USING iLines[]
                                 newFilenameWithPath
                                 newfilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    ELSE.
      PERFORM saveFileToServer USING iLines[]
                                     newFilenameWithPath
                                     newfilenameOnly
                                     completeSavePath
                                     displayProgressMessage
                                     locServerFileSystem.
    ENDIF.

    documentationDownloaded = true.
  ENDIF.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
* downloadClassDocs...
*----------------------------------------------------------------------------------------------------------------------
FORM downloadClassDocs USING VALUE(className) TYPE seoclsname
                             VALUE(userFilePath)
                             VALUE(fileExtension)
                             VALUE(convertToHtml)
                             VALUE(slashSeparator)
                             VALUE(saveToServer)
                             VALUE(displayProgressMessage)
                                   subDir
                                   documentationDownloaded
                             VALUE(locServerFileSystem)
                             VALUE(addBackground) TYPE abap_bool.

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: iDocumentation TYPE STANDARD TABLE OF funct WITH HEADER LINE.
  DATA: iExceptions TYPE STANDARD TABLE OF rsexc WITH HEADER LINE.
  DATA: iExport TYPE STANDARD TABLE OF rsexp WITH HEADER LINE.
  DATA: iParameter TYPE STANDARD TABLE OF rsimp WITH HEADER LINE.
  DATA: iTables TYPE STANDARD TABLE OF rstbl WITH HEADER LINE.
  DATA: iScriptLines TYPE STANDARD TABLE OF tline WITH HEADER LINE.
  DATA: htmlPageName TYPE string.
  DATA: newFilenameWithPath TYPE string.
  DATA: newFilenameOnly TYPE string.
  DATA: object LIKE dokhl-object.
  DATA: stringLength TYPE i VALUE 0.
  DATA: newSubDirectory TYPE string.
  DATA: waLine(255).
  DATA: completeSavePath TYPE string.

  documentationDownloaded = false.
  object = className.

  CALL FUNCTION 'DOC_OBJECT_GET'
    EXPORTING
      class            = 'CL'
      name             = object
      language         = pMLang
*     short_text       = ' '
*     appendix         = ' '
*   importing
*     header           = header
    TABLES
      itf_lines        = iScriptLines[]
    EXCEPTIONS
      object_not_found = 1.

  IF sy-subrc = 0 AND NOT ( iScriptLines[] IS INITIAL ).
    LOOP AT iScriptLines.
      MOVE iScriptLines-tdline TO iLines.
      CONCATENATE space iLines INTO iLines SEPARATED BY space.
      WHILE iLines CP '&*' OR iLines CP '*&'.
        REPLACE '&' INTO iLines WITH space.
        SHIFT iLines LEFT DELETING LEADING space.
      ENDWHILE.
      APPEND iLines.
    ENDLOOP.

    CONCATENATE `Documentation - ` className INTO htmlPageName.

    IF convertToHtml IS INITIAL.
      APPEND iLines.
      APPEND  '----------------------------------------------------------------------------------' TO iLines.
      APPEND iLines.
      PERFORM buildFooterMessage USING iLines.
      APPEND iLines.
    ELSE.
      PERFORM convertCodeToHtml USING iLines[]
                                      htmlPageName
                                      space
                                      is_documentation
                                      true
                                      space
                                      space
                                      space
                                      space
                                      space
                                      addBackground.
    ENDIF.

    PERFORM buildFilename USING userFilePath
                                subDir
                                className
                                space
                                space
                                fileExtension
                                is_documentation
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newFilenameOnly
                                newSubDirectory
                                completeSavePath.

    IF saveToServer IS INITIAL.
      PERFORM saveFileToPC USING iLines[]
                                 newFilenameWithPath
                                 newfilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    ELSE.
      PERFORM saveFileToServer USING iLines[]
                                     newFilenameWithPath
                                     newfilenameOnly
                                     completeSavePath
                                     displayProgressMessage
                                     locServerFileSystem.
    ENDIF.

    documentationDownloaded = true.
  ENDIF.
ENDFORM.
*----------------------------------------------------------------------------------------------------------------------
*  downloadScreens...
*----------------------------------------------------------------------------------------------------------------------
FORM downloadScreens USING iLocScreenFlow LIKE dumiScreen[]
                           VALUE(programName)
                           VALUE(userFilePath)
                           VALUE(textFileExtension)
                           VALUE(subdir)
                           VALUE(slashSeparator)
                           VALUE(saveToServer)
                           VALUE(displayProgressMessage)
                           VALUE(locServerFileSystem).


  TABLES: d020t.
  DATA: header LIKE d020s.
  DATA: iFields TYPE STANDARD TABLE OF d021s WITH HEADER LINE.
  DATA: iFlowLogic TYPE STANDARD TABLE OF d022s WITH HEADER LINE.
  FIELD-SYMBOLS <waScreen> TYPE tScreenFlow.
  DATA: waCharHeader TYPE scr_chhead.
  DATA: iScreenChar TYPE STANDARD TABLE OF scr_chfld WITH HEADER LINE.
  DATA: iFieldsChar TYPE STANDARD TABLE OF scr_chfld WITH HEADER LINE.
  DATA: stars TYPE string VALUE '****************************************************************'.
  DATA: comment1 TYPE string VALUE '*   This file was generated by Direct Download Enterprise.     *'.
  DATA: comment2 TYPE string VALUE '*   Please do not change it manually.                          *'.
  DATA: dynproText TYPE string VALUE '%_DYNPRO'.
  DATA: headerText TYPE string VALUE '%_HEADER'.
  DATA: paramsText TYPE string VALUE '%_PARAMS'.
  DATA: descriptionText TYPE string VALUE '%_DESCRIPTION'.
  DATA: fieldsText TYPE string VALUE '%_FIELDS'.
  DATA: flowlogicText TYPE string VALUE '%_FLOWLOGIC'.
  DATA: programLength TYPE string.
  DATA: newSubDirectory TYPE string.
  DATA: newFilenameWithPath TYPE string.
  DATA: newFilenameOnly TYPE string.
  DATA: completeSavePath TYPE string.

  LOOP AT iLocScreenFlow ASSIGNING <waScreen>.
    CALL FUNCTION 'RS_IMPORT_DYNPRO'
      EXPORTING
        dylang = pMLang
        dyname = programName
        dynumb = <waScreen>-screen
      IMPORTING
        header = header
      TABLES
        ftab   = iFields
        pltab  = iFlowLogic.

    CALL FUNCTION 'RS_SCRP_HEADER_RAW_TO_CHAR'
      EXPORTING
        header_int  = header
      IMPORTING
        header_char = waCharHeader
      EXCEPTIONS
        OTHERS      = 1.

*   Add in the top comments for the file
    APPEND stars TO iScreenChar .
    APPEND comment1 TO iScreenChar.
    APPEND comment2 TO iScreenChar.
    APPEND stars TO iScreenChar.

*   Screen identification
    APPEND dynproText TO iScreenChar.
    APPEND waCharHeader-prog TO iScreenChar.
    APPEND waCharHeader-dnum TO iScreenChar.
    APPEND sy-saprl TO iScreenChar.
    DESCRIBE FIELD d020t-prog LENGTH programLength IN CHARACTER MODE.
    CONCATENATE `                ` programLength INTO iScreenChar.
    APPEND iScreenChar.

*   Header
    APPEND headerText TO iScreenChar.
    APPEND waCharHeader TO iScreenChar.

*   Description text
    APPEND descriptionText TO iScreenChar.
    SELECT SINGLE dtxt FROM d020T INTO iScreenChar
                       WHERE prog = programName
                             AND dynr = <waScreen>-screen
                             AND lang = pMLang.
    APPEND iScreenChar.

*   Fieldlist text
    APPEND fieldsText TO iScreenChar.

    CALL FUNCTION 'RS_SCRP_FIELDS_RAW_TO_CHAR'
      TABLES
        fields_int  = iFields[]
        fields_char = iFieldsChar[]
      EXCEPTIONS
        OTHERS      = 1.

    LOOP AT iFieldsChar.
      MOVE-CORRESPONDING iFieldsChar TO iScreenChar.
      APPEND iScreenChar.
    ENDLOOP.

*   Flowlogic text
    APPEND flowlogicText TO iScreenChar.
*   Flow logic.
    LOOP AT iFlowLogic.
      APPEND iFlowLogic TO iScreenChar.
    ENDLOOP.

    PERFORM buildFilename USING userFilePath
                                subDir
                                waCharHeader-dnum
                                space
                                space
                                textFileExtension
                                is_screen
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newfilenameOnly
                                newSubDirectory
                                completeSavePath.

    IF saveToServer IS INITIAL.
*     Save the screen to the local computer
      PERFORM saveFileToPc USING iScreenChar[]
                                 newFilenameWithPath
                                 newFilenameOnly
                                 'X'
                                 'X'
                                 displayProgressMessage.
    ELSE.
*     Save the screen to the SAP server
      PERFORM saveFileToServer USING iScreenChar[]
                                     newFilenameWithPath
                                     newFilenameOnly
                                     completeSavePath
                                     displayProgressMessage
                                     locServerFileSystem.
    ENDIF.

    CLEAR header. CLEAR waCharHeader.
    CLEAR iScreenChar[].
    CLEAR iFieldsChar[].
    CLEAR iFields[].
    CLEAR iFlowLogic[].
  ENDLOOP.
ENDFORM.                                                                                               "downloadScreens

*----------------------------------------------------------------------------------------------------------------------
*  downloadGUITitles..
*----------------------------------------------------------------------------------------------------------------------
FORM downloadGUITitles USING iLocGUITitles LIKE dumIGUITitle[]
                             VALUE(userFilePath)
                             VALUE(textFileExtension)
                             VALUE(subDir)
                             VALUE(slashSeparator)
                             VALUE(saveToServer)
                             VALUE(displayProgressMessage)
                             VALUE(locServerFileSystem).

  DATA: iLines TYPE STANDARD TABLE OF string WITH HEADER LINE.
  FIELD-SYMBOLS: <waGUITitle> TYPE tGUITitle.
  DATA: newSubDirectory TYPE string.
  DATA: newFilenameWithPath TYPE string.
  DATA: newFilenameOnly TYPE string.
  DATA: completeSavePath TYPE string.

  LOOP AT iLocGUITitles ASSIGNING <waGUITitle>.
    APPEND <waGUITitle>-text TO iLines.

    PERFORM buildFilename USING userFilePath
                                subDir
                                <waGUITitle>-obj_code
                                space
                                space
                                textFileExtension
                                is_guititle
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newfilenameOnly
                                newSubDirectory
                                completeSavePath.

    IF saveToServer IS INITIAL.
      PERFORM saveFileToPc USING iLines[]
                                 newFilenameWithPath
                                 newFilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    ELSE.
      PERFORM saveFileToServer USING iLines[]
                                     newFilenameWithPath
                                     newFilenameOnly
                                     completeSavePath
                                     displayProgressMessage
                                     locServerFileSystem.
    ENDIF.

    CLEAR iLines[].
  ENDLOOP.
ENDFORM.                                                                                             "downloadGUITitles

*----------------------------------------------------------------------------------------------------------------------
*  downloadPrograms..
*----------------------------------------------------------------------------------------------------------------------
FORM downloadPrograms USING iLocProgram LIKE iPrograms[]
                            iLocFunctions LIKE iFunctions[]
                            iLocDictionaryFilename LIKE iDictFilename[]
                            VALUE(userFilePath)
                            VALUE(fileExtension)
                            VALUE(htmlFileExtension)
                            VALUE(textFileExtension)
                            VALUE(convertToHtml)
                            VALUE(customerNameRange)
                            VALUE(getIncludes)
                            VALUE(getDictStruct)
                            VALUE(downloadDocumentation)
                            VALUE(sortTablesAsc)
                            VALUE(slashSeparator)
                            VALUE(saveToServer)
                            VALUE(displayProgressMessage)
                            VALUE(locServerFileSystem)
                            VALUE(addBackground) TYPE abap_bool.


  DATA: iProgFunctions TYPE STANDARD TABLE OF tFunction WITH HEADER LINE.
  FIELD-SYMBOLS: <waProgram> TYPE tProgram.
  FIELD-SYMBOLS: <waInclude> TYPE tInclude.
  DATA: iEmptyTextelements TYPE STANDARD TABLE OF tTextTable.
  DATA: iEmptySelectionTexts TYPE STANDARD TABLE OF tTextTable.
  DATA: iEmptyMessages TYPE STANDARD TABLE OF tMessage.
  DATA: iEmptyGuiTitles TYPE STANDARD TABLE OF tGUITitle.
  DATA: locConvertToHtml(1).
  DATA: locFileExtension TYPE string.

  SORT iLocProgram ASCENDING BY progname.

  LOOP AT iLocProgram ASSIGNING <waProgram>.
*   if the program to download is this program then always download as text otherwise you will get a rubbish file
    IF <waprogram>-progname = sy-cprog.
      locConvertToHtml = ''.
      locFileExtension = textextension.
    ELSE.
      locConvertToHtml = convertToHtml.
      locFileExtension = fileExtension.
    ENDIF.

*   Download the main program
    PERFORM readIncludeAndDownload USING <waProgram>-iTextelements[]
                                         <waProgram>-iSelectionTexts[]
                                         <waProgram>-iMessages[]
                                         <waProgram>-iGUITitle[]
                                         <waprogram>-progname
                                         space
                                         <waprogram>-programTitle
                                         is_program
                                         userFilePath
                                         locFileExtension
                                         <waprogram>-progname
                                         locConvertToHtml
                                         customerNameRange
                                         getIncludes
                                         getDictStruct
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         locServerFileSystem
                                         addBackground.

*   Download screens.
    IF NOT <waProgram>-iScreenFlow[] IS INITIAL.
      PERFORM downloadScreens USING <waProgram>-iScreenFlow[]
                                    <waProgram>-progname
                                    userFilePath
                                    textFileExtension
                                    <waprogram>-progname
                                    slashSeparator
                                    saveToServer
                                    displayProgressMessage
                                    locServerFileSystem.
    ENDIF.

*   Download GUI titles
    IF NOT <waProgram>-iGUITitle[] IS INITIAL.
      PERFORM downloadGUITitles USING <waProgram>-iGUITitle
                                      userFilePath
                                      textFileExtension
                                      <waProgram>-progName
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage
                                      locServerFileSystem.
    ENDIF.

*   Download all other includes
    LOOP AT <waProgram>-iIncludes ASSIGNING <waInclude>.
      PERFORM readIncludeAndDownload USING iEmptyTextelements[]
                                           iEmptySelectionTexts[]
                                           iEmptyMessages[]
                                           iEmptyGuiTitles[]
                                           <waInclude>-IncludeName
                                           space
                                           <waInclude>-IncludeTitle
                                           is_program
                                           userFilePath
                                           fileExtension
                                           <waProgram>-progName
                                           convertToHtml
                                           customerNameRange
                                           getIncludes
                                           getDictStruct
                                           slashSeparator
                                           saveToServer
                                           displayProgressMessage
                                           locServerFileSystem
                                           addBackground.

    ENDLOOP.

*   Download all dictionary structures
    IF NOT <waProgram>-iDictStruct[] IS INITIAL.
      PERFORM downloadDDStructures USING <waProgram>-iDictStruct[]
                                         iLocDictionaryFilename[]
                                         userFilePath
                                         htmlFileExtension
                                         <waProgram>-progName
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         locServerFileSystem
                                         addBackground.
    ENDIF.

*   Download any functions used by these programs
    LOOP AT iLocFunctions INTO iProgFunctions WHERE programLinkName = <waProgram>-progName.
      APPEND iProgFunctions.
    ENDLOOP.

    IF NOT iProgFunctions[] IS INITIAL.
      PERFORM downloadFunctions USING iProgFunctions[]
                                      iLocDictionaryFilename[]
                                      userFilePath
                                      fileExtension
                                      <waProgram>-progName
                                      downloadDocumentation
                                      convertToHtml
                                      customerNameRange
                                      getIncludes
                                      getDictStruct
                                      textFileExtension
                                      htmlFileExtension
                                      sortTablesAsc
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage
                                      locServerFileSystem
                                      addBackground.
      CLEAR iProgFunctions[].
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                              "downloadPrograms

*----------------------------------------------------------------------------------------------------------------------
*  downloadClasses..
*----------------------------------------------------------------------------------------------------------------------
FORM downloadClasses USING iLocClasses LIKE iClasses[]
                           iLocFunctions LIKE iFunctions[]
                           iLocDictionaryFilename LIKE iDictFilename[]
                           VALUE(userFilePath)
                           VALUE(fileExtension)
                           VALUE(htmlFileExtension)
                           VALUE(textFileExtension)
                           VALUE(convertToHtml)
                           VALUE(customerNameRange)
                           VALUE(getIncludes)
                           VALUE(getDictStruct)
                           VALUE(downloadDocumentation)
                           VALUE(sortTablesAsc)
                           VALUE(slashSeparator)
                           VALUE(saveToServer)
                           VALUE(displayProgressMessage)
                           VALUE(locServerFileSystem)
                           VALUE(addBackground) TYPE abap_bool.


  DATA: iClassFunctions TYPE STANDARD TABLE OF tFunction WITH HEADER LINE.
  FIELD-SYMBOLS: <waClass> TYPE tClass.
  FIELD-SYMBOLS: <waMethod> TYPE tMethod.
  DATA: additionalSubDirectory TYPE string.
  DATA: classDocumentationExists TYPE abap_bool VALUE false.

  SORT iLocClasses ASCENDING BY clsname.

  LOOP AT iLocClasses ASSIGNING <waClass>.
*   Download the class
    PERFORM readClassAndDownload USING <waClass>
                                        <waClass>-clsname
                                        space
                                        is_class
                                        userFilePath
                                        fileExtension
                                        space
                                        convertToHtml
                                        customerNameRange
                                        getIncludes
                                        getDictStruct
                                        slashSeparator
                                        saveToServer
                                        displayProgressMessage
                                        locServerFileSystem
                                        addBackground.


*   Download all of the methods
    LOOP AT <waClass>-iMethods ASSIGNING <waMethod>.
      additionalSubDirectory = <waClass>-clsName.
      PERFORM readMethodAndDownload USING <waMethod>
                                          <waMethod>-cmpName
                                          <waMethod>-methodKey
                                          space
                                          is_method
                                          userFilePath
                                          fileExtension
                                          additionalSubDirectory
                                          convertToHtml
                                          customerNameRange
                                          getIncludes
                                          getDictStruct
                                          slashSeparator
                                          saveToServer
                                          displayProgressMessage
                                          locServerFileSystem
                                          addBackground.

    ENDLOOP.

*   Download all dictionary structures
    IF NOT <waClass>-iDictStruct[] IS INITIAL.
      PERFORM downloadDDStructures USING <waClass>-iDictStruct[]
                                         iLocDictionaryFilename[]
                                         userFilePath
                                         htmlFileExtension
                                         <waClass>-clsName
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         locServerFileSystem
                                         addBackground.
    ENDIF.

*   Download any functions used by these programs
    LOOP AT iLocFunctions INTO iClassFunctions WHERE programLinkName = <waClass>-clsName.
      APPEND iClassFunctions.
    ENDLOOP.

    IF NOT iClassFunctions[] IS INITIAL.
      PERFORM downloadFunctions USING iClassFunctions[]
                                      iLocDictionaryFilename[]
                                      userFilePath
                                      fileExtension
                                      <waClass>-clsName
                                      downloadDocumentation
                                      convertToHtml
                                      customerNameRange
                                      getIncludes
                                      getDictStruct
                                      textFileExtension
                                      htmlFileExtension
                                      sortTablesAsc
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage
                                      locServerFileSystem
                                      addBackground.
      CLEAR iClassFunctions[].
    ENDIF.

    IF downloadDocumentation = true.
      PERFORM downloadClassDocs USING <waClass>-clsName
                                       userFilePath
                                       fileExtension
                                       convertToHtml
                                       slashSeparator
                                       saveToServer
                                       displayProgressMessage
                                      '' "subdirectory
                                       classDocumentationExists
                                       locServerFileSystem
                                       addBackground.
    ENDIF.
  ENDLOOP.
ENDFORM.                                                                                               "downloadClasses

*----------------------------------------------------------------------------------------------------------------------
*  reFormatClassCode...   Expand a classes public, private and protected section from the 72 characters that the class
*                         builder sets it to back to the wide editor mode
*----------------------------------------------------------------------------------------------------------------------
FORM reFormatClassCode USING iTempLines LIKE dumiHtml[].

  FIELD-SYMBOLS: <waLine> TYPE string.
  DATA: newLine TYPE string.
  DATA: iNewTable TYPE STANDARD TABLE OF string.
  DATA: foundOne TYPE abap_bool VALUE false.

  LOOP AT iTempLines ASSIGNING <waLine>.
    IF NOT <waLine> IS INITIAL.
      IF foundOne = false.
        FIND 'data' IN <waLine> RESPECTING CASE.
        IF sy-subrc = 0.
          foundOne = true.
        ENDIF.

        FIND 'constants' IN <waLine> RESPECTING CASE.
        IF sy-subrc = 0.
          foundOne = true.
        ENDIF.

        IF foundOne = true.
          newLine = <waLine>.

          IF ( newLine CS '.' OR newLine CS '*' ).
            REPLACE '!' IN <waLine> WITH ''.
            APPEND newLine TO iNewTable.
            CLEAR newLine.
            foundOne = false.
          ENDIF.
        ELSE.
          REPLACE '!' IN <waLine> WITH ''.
          APPEND <waLine> TO iNewTable.
        ENDIF.
      ELSE.
        CONCATENATE newLine <waLine> INTO newLine SEPARATED BY space.
        IF ( newLine CS '.' OR newLine CS '*' ).
          APPEND newLine TO iNewTable.
          CLEAR newLine.
          foundOne = false.
        ENDIF.
      ENDIF.
    ELSE.
      REPLACE '!' IN <waLine> WITH ''.
      APPEND <waLine> TO iNewTable[].
    ENDIF.
  ENDLOOP.

  iTempLines[] = iNewTable[].
ENDFORM.                                                                             "reFormatClassCode

***********************************************************************************************************************
**********************************************HTML ROUTINES************************************************************
***********************************************************************************************************************

*----------------------------------------------------------------------------------------------------------------------
*  convertDDToHTML...   Convert text description to HTML
*----------------------------------------------------------------------------------------------------------------------
FORM convertDDToHTML USING iLocDictStructure LIKE dumiDictStructure[]
                           iLocHtml LIKE dumiHtml[]
                           VALUE(tableName)
                           VALUE(tableTitle)
                           VALUE(sortTablesAsc)
                           VALUE(addBackground) TYPE abap_bool..

  DATA: iColumnCaptions TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: waDictionary TYPE tDictTableStructure.
  DATA: waHtml TYPE string.
  DATA: title TYPE string.
  FIELD-SYMBOLS: <iLocDictStructure> TYPE tDictTableStructure.
* Holds one cell from the internal table
  FIELD-SYMBOLS: <fsField>.
* The value of one cell form the internal table
  DATA: wTextCell TYPE string.
  DATA: rowCounter(3).

  PERFORM buildColumnHeaders USING iColumnCaptions[].

* Add a html header to the table
  CONCATENATE 'Dictionary object-' tablename INTO title SEPARATED BY space.
  PERFORM addHTMLHeader USING iLocHtml[]
                              title
                              addBackground
                              ss_table.

  APPEND `<body>` TO iLocHtml.
  APPEND `  <table class="outerTable">` TO iLocHtml.
  APPEND `    <tr>` TO iLocHtml.
  CONCATENATE `      <td><h2>Table: ` tableName '</h2>' INTO waHtml.
  APPEND waHtml TO iLocHtml.
  CONCATENATE `  <h3>Description: ` tableTitle '</h3></td>' INTO waHtml.
  APPEND waHtml TO iLocHtml.
  APPEND `    </tr>` TO iLocHtml.

  APPEND `    <tr>` TO iLocHtml.
  APPEND `      <td><!--This is where our main table begins  -->` TO iLocHtml.
  APPEND `<table class="innerTable">` TO iLocHtml.

* Do we need to sort the fields into alphabetical order
  IF NOT sortTablesAsc IS INITIAL.
    SORT iLocDictStructure ASCENDING BY fieldname.
  ENDIF.

* This is where the header fields are defined
  APPEND `<tr>` TO iLocHtml.
  LOOP AT iColumnCaptions.
    CONCATENATE `  <th>` iColumnCaptions `</th>` INTO waHtml.
    APPEND waHtml TO iLocHtml.
  ENDLOOP.
  APPEND `</tr>` TO iLocHtml.

* Add the table cells here
  LOOP AT iLocDictStructure ASSIGNING <iLocDictStructure>.
    APPEND `<tr class="cell">` TO iLocHtml.
    rowcounter = rowcounter + 1.
    CONCATENATE `  <td>` rowcounter `</td>` INTO waHtml.
    APPEND waHtml TO iLocHtml.

    DO.
*     Assign each field in the table to the field symbol
      ASSIGN COMPONENT sy-index OF STRUCTURE <iLocDictStructure> TO <fsField>.
      IF sy-subrc = 0.
        MOVE <fsField> TO wTextCell.
        waHtml = `  <td>`.

*       Add the caption name
        IF wTextCell IS INITIAL.
          CONCATENATE waHtml '&nbsp;' '</td>' INTO waHtml.
        ELSE.
          CONCATENATE waHtml wTextCell '</td>' INTO waHtml.
        ENDIF.

        APPEND waHtml TO iLocHtml.
        CLEAR waHtml.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.

    APPEND `</tr>` TO iLocHtml.
  ENDLOOP.

  APPEND `      </table>` TO iLocHtml.
  APPEND `     </td>` TO iLocHtml.
  APPEND `   </tr>` TO iLocHtml.

* Add a html footer to the table
  PERFORM addHtmlFooter USING iLocHtml[].
ENDFORM.                                                                                               "convertDDToHTML
"convertITABtoHtml

*----------------------------------------------------------------------------------------------------------------------
*  convertCodeToHtml... Builds an HTML table based upon a text table.
*----------------------------------------------------------------------------------------------------------------------
FORM convertCodeToHtml USING iContents LIKE dumIHtml[]
                             VALUE(programName)
                             VALUE(ShortDescription)
                             VALUE(sourceCodeType)
                             VALUE(functionDocumentationExists)
                             VALUE(isMainFunctionInclude)
                             VALUE(htmlExtension)
                             VALUE(customerNameRange)
                             VALUE(getIncludes)
                             VALUE(getDictStructures)
                             VALUE(addBackground) TYPE abap_bool.

  DATA: htmlTable TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: head(255).
  DATA: tail(255).
  DATA: myTabix TYPE syTabix.
  DATA: nextLine TYPE syTabix.
  DATA: hyperlinkName TYPE string.
  DATA: copyOfCurrentLine TYPE string.
  DATA: currentLineLength TYPE i VALUE 0.
  DATA: copyLineLength TYPE i VALUE 0.
  DATA: ignoreFutureLines TYPE abap_bool VALUE false.
  DATA: foundAsterix TYPE abap_bool VALUE false.
  DATA: lowercaseLink TYPE string.
  DATA: waNextLine TYPE string.
  DATA: waContent TYPE string.
  DATA: inCommentMode TYPE abap_bool VALUE 'X'.

* Add a html header to the table
  PERFORM addHTMLHeader USING htmlTable[]
                              programName
                              addBackground
                              ss_code.

  APPEND '<body>' TO htmlTable.
* Prgroamname and description
  APPEND '<table class="outerTable">' TO htmlTable.
  APPEND `  <tr class="normalBoldLarge">` TO htmlTable.

  CONCATENATE `     <td><h2>Code listing for: ` programName `</h2>` INTO htmlTable.
  APPEND htmlTable.

  CONCATENATE `<h3> Description: ` ShortDescription `</h3></td>` INTO htmlTable.
  APPEND htmlTable.
  APPEND `   </tr>` TO htmlTable.

* Code
  APPEND `  <tr>` TO htmlTable.
  APPEND `     <td>` TO htmlTable.

* Table containing code
  APPEND `     <table class="innerTable">` TO htmlTable.
  APPEND `       <tr>` TO htmlTable.
  APPEND `          <td>` TO htmlTable.


  LOOP AT iContents INTO waContent.
    myTabix = sy-tabix.

    IF NOT ( waContent IS INITIAL ).
      WHILE ( waContent CS '<' OR waContent CS '>' ).
        REPLACE '<' IN waContent WITH lt.
        REPLACE '>' IN waContent WITH gt.
      ENDWHILE.

      IF waContent+0(1) <> asterix.
        IF myTabix = 1.
          APPEND `   <div class="code">` TO htmlTable.
          inCommentMode = false.
        ELSE.
          IF inCommentMode = true.
            APPEND `   </div>` TO htmlTable.
            inCommentMode = false.
            APPEND `   <div class="code">` TO htmlTable.
          ENDIF.
        ENDIF.

        currentLineLength = strlen( waContent ).
        copyOfCurrentLine = waContent.

*       Don't hyperlink anything for files of type documentation
        IF sourceCodeType <> is_documentation.
*         Check for any functions to highlight
          IF ( waContent CS callfunction ) AND ( waContent <> 'DESTINATION' ).
            nextLine = myTabix + 1.
            READ TABLE iContents INTO waNextLine INDEX nextLine.
            TRANSLATE waNextLine TO UPPER CASE.
            IF waNextLine NS 'DESTINATION'.
              SHIFT copyOfCurrentLine LEFT DELETING LEADING space.

              copyLineLength = strlen( copyofCurrentLine ).

              SPLIT copyOfCurrentLine AT space INTO head tail.
              SPLIT tail AT space INTO head tail.
              SPLIT tail AT space INTO head tail.
*             Function name is now in head
              TRANSLATE head USING ''' '.
              SHIFT head LEFT DELETING LEADING space.

              TRY.
                  IF head+0(1) = 'Y' OR head+0(1) = 'Z' OR head+0(1) = 'y' OR head+0(1) = 'z' OR head CS customerNameRange.
*                 Definately a customer function module
                    hyperLinkName = head.

                    IF sourceCodeType = is_function.
                      copyOfCurrentLine = 'call function <a href ="../'.
                    ELSE.
                      copyOfCurrentLine = 'call function <a href ="'.
                    ENDIF.

                    lowercaseLink = hyperlinkName.
                    TRANSLATE lowercaseLink TO LOWER CASE.
*                 If we are running on a non UNIX environment we will need to remove forward slashes
                    IF frontendOpSystem = non_unix.
                      TRANSLATE lowercaseLink USING '/_'.
                    ENDIF.

                    CONCATENATE copyOfCurrentLine
                                lowercaseLink     "hyperlinkName
                                '/'
                                lowercaseLink     "hyperlinkName
                                Period htmlExtension '">'
                                ''''
                                hyperlinkName
                                ''''
                                '</a>'
                                tail INTO copyOfCurrentLine.

*                 Pad the string back out with spaces
                    WHILE copyLineLength < currentLineLength.
                      SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                      copyLineLength = copyLineLength + 1.
                    ENDWHILE.

                    waContent = copyOfCurrentLine.
                  ENDIF.
                CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
              ENDTRY.
            ENDIF.
          ENDIF.
        ENDIF.

*       Check for any customer includes to hyperlink
        IF waContent CS include OR waContent CS lowinclude.
          SHIFT copyOfCurrentLine LEFT DELETING LEADING space.
          copyLineLength = strlen( copyOfCurrentLine ).

          SPLIT copyOfCurrentLine AT space INTO head tail.
          SHIFT tail LEFT DELETING LEADING space.

          TRY.
              IF ( tail+0(1) = 'Y' OR tail+0(1) = 'Z' OR tail+0(1) = 'y' OR tail+0(1) = 'z' OR tail CS customerNameRange OR tail+0(2) = 'mz' OR tail+0(2) = 'MZ' )
                  AND NOT getIncludes IS INITIAL AND  tail NS structure AND tail NS lowstructure.

*             Hyperlink for program includes
                CLEAR waContent.
                SHIFT tail LEFT DELETING LEADING space.
                SPLIT tail AT period INTO hyperlinkName tail.
                copyOfCurrentLine = 'include <a href ="'.

                lowercaseLink = hyperlinkName.
                TRANSLATE lowercaseLink TO LOWER CASE.

*             If we are running on a non UNIX environment we will need to remove forward slashes
                IF frontendOpSystem = non_unix.
                  TRANSLATE lowercaseLink USING '/_'.
                ENDIF.

                CONCATENATE copyOfCurrentLine
                            lowercaseLink       "hyperlinkName
                            period htmlExtension '">'
                            hyperlinkName
                            '</a>'
                            period tail INTO copyOfCurrentLine.

*             Pad the string back out with spaces
                WHILE copyLineLength < currentLineLength.
                  SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                  copyLineLength = copyLineLength + 1.
                ENDWHILE.
                waContent = copyOfCurrentLine.
              ELSE.
                IF NOT getDictStructures IS INITIAL.
*              Hyperlink for structure include e.g. "include structure zfred."
                  copyLineLength = strlen( copyofCurrentLine ).
                  SPLIT copyOfCurrentLine AT space INTO head tail.
                  SHIFT tail LEFT DELETING LEADING space.
                  SPLIT tail AT space INTO head tail.

                  TRY.
                      IF tail+0(1) = 'Y' OR tail+0(1) = 'Z' OR tail+0(1) = 'y' OR tail+0(1) = 'z' OR tail CS customerNameRange.
                        CLEAR waContent.
                        SHIFT tail LEFT DELETING LEADING space.
                        SPLIT tail AT period INTO hyperlinkName tail.
                        copyOfCurrentLine = 'include structure <a href ='.

                        lowercaseLink = hyperlinkName.
                        TRANSLATE lowercaseLink TO LOWER CASE.
*                  If we are running on a non UNIX environment we will need to remove forward slashes
                        IF frontendOpSystem = non_unix.
                          TRANSLATE lowercaseLink USING '/_'.
                        ENDIF.

                        CONCATENATE copyOfCurrentLine
                                    '"'
                                    lowercaseLink    "hyperlinkName
                                    '/'
                                    'dictionary-'
                                    lowercaseLink    "hyperlinkName
                                    period htmlExtension
                                    '">'
                                    hyperlinkName
                                    '</a>'
                                    period tail INTO copyOfCurrentLine.

*                  Pad the string back out with spaces
                        WHILE copyLineLength < currentLineLength.
                          SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                          copyLineLength = copyLineLength + 1.
                        ENDWHILE.
                        waContent = copyOfCurrentLine.
                      ENDIF.
                    CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
                  ENDTRY.
                ENDIF.
              ENDIF.
            CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
          ENDTRY.
        ENDIF.
      ELSE.
        IF  waContent+0(1) = asterix.
          IF myTabix = 1.
            APPEND `   <div class="codeComment">` TO htmlTable.
            inCommentMode = true.
          ELSE.
            IF inCommentMode = false.
              APPEND `   </div>` TO htmlTable.
              APPEND `   <div class="codeComment">` TO htmlTable.
              inCommentMode = true.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.


      IF inCommentMode = true.
        WHILE waContent CS ' '.
          REPLACE space WITH '&nbsp;' INTO waContent.
          IF sy-subrc <> 0.
            EXIT.
          ENDIF.
        ENDWHILE.
      ENDIF.
      htmlTable =  waContent.

      TRY.
          IF htmlTable+0(1) = ` `.
            WHILE htmlTable CS ` `.
              REPLACE ` ` WITH '&nbsp;' INTO htmlTable.
              IF sy-subrc <> 0.
                EXIT.
              ENDIF.
            ENDWHILE.
          ENDIF.
        CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
      ENDTRY.
    ELSE.
      htmlTable = ''.
    ENDIF.
    CONCATENATE htmlTable `<br />` INTO htmlTable.
    APPEND htmlTable.
  ENDLOOP.

  APPEND `            </div>` TO htmlTable.
  APPEND `          </td>`  TO htmlTable.
  APPEND `        </tr>` TO htmlTable.
  APPEND `      </table>` TO htmlTable.
  APPEND `      </td>` TO htmlTable.
  APPEND `      </tr>` TO htmlTable.

* Add a html footer to the table
  PERFORM addHtmlFooter USING htmlTable[].

  iContents[] = htmlTable[].
ENDFORM.                                                                                             "convertCodeToHtml

*----------------------------------------------------------------------------------------------------------------------
*  convertClassToHtml... Builds an HTML table based upon a text table.
*----------------------------------------------------------------------------------------------------------------------
FORM convertClassToHtml USING iContents LIKE dumIHtml[]
                              VALUE(className)
                              VALUE(ShortDescription)
                              VALUE(sourceCodeType)
                              VALUE(htmlExtension)
                              VALUE(customerNameRange)
                              VALUE(getDictStructures)
                              VALUE(addBackground) TYPE abap_bool.

  DATA: htmlTable TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: myTabix TYPE syTabix.
  DATA: waContent TYPE string.
  DATA: head TYPE string.
  DATA: tail TYPE string.
  DATA: hyperlinkName TYPE string.
  DATA: lowercaseLink TYPE string.
  DATA: copyOfCurrentLine TYPE string.
  DATA: currentLineLength TYPE i VALUE 0.
  DATA: copyLineLength TYPE i VALUE 0.
  DATA: inCommentMode TYPE abap_bool VALUE 'X'.
  DATA: methoddirectory TYPE string.

* Add a html header to the table
  PERFORM addHTMLHeader USING htmlTable[]
                              className
                              addBackground
                              ss_code.

  APPEND '<body>' TO htmlTable.
* Class name and description
  APPEND '<table class="outerTable">' TO htmlTable.
  APPEND `  <tr class="normalBoldLarge">` TO htmlTable.

  CONCATENATE `     <td><h2>Code listing for class: ` className `</h2>` INTO htmlTable.
  APPEND htmlTable.

  CONCATENATE `<h3> Description: ` ShortDescription `</h3></td>` INTO htmlTable.
  APPEND htmlTable.
  APPEND `   </tr>` TO htmlTable.

* Code
  APPEND `  <tr>` TO htmlTable.
  APPEND `     <td>` TO htmlTable.

* Table containing code
  APPEND `     <table class="innerTable">` TO htmlTable.
  APPEND `       <tr>` TO htmlTable.
  APPEND `          <td>` TO htmlTable.


  LOOP AT iContents INTO waContent.
    myTabix = sy-tabix.

*   Comments
    IF NOT ( waContent IS INITIAL ).
      IF waContent+0(1) = asterix.
        htmltable = wacontent.
        IF myTabix = 1.
          APPEND `   <div class="codeComment">` TO htmlTable.
          inCommentMode = true.
        ELSE.
          IF inCommentMode = false.
            APPEND `   </div>` TO htmlTable.
            APPEND `   <div class="codeComment">` TO htmlTable.
            inCommentMode = true.
          ENDIF.
        ENDIF.
      ELSE.
        IF myTabix = 1.
          APPEND `   <div class="code">` TO htmlTable.
          inCommentMode = false.
        ELSE.
          IF inCommentMode = true.
            APPEND `   </div>` TO htmlTable.
            inCommentMode = false.
            APPEND `   <div class="code">` TO htmlTable.
          ENDIF.
        ENDIF.

*        Smaller than, greater than signs
        IF NOT ( waContent IS INITIAL ).
          WHILE ( waContent CS '<' OR waContent CS '>' ).
            REPLACE '<' IN waContent WITH lt.
            REPLACE '>' IN waContent WITH gt.
          ENDWHILE.

*--        Hyperlink methods in the class
*--        Setup sudirectory where method will be saved
          IF wacontent CS 'public section.'.
            methoddirectory = 'public_methods'.
          ELSEIF wacontent CS 'private section.'.
            methoddirectory = 'private_methods'.
          ELSEIF wacontent CS 'protected section.'.
            methoddirectory = 'protected_methods'.
          ENDIF.

*--        When it is a method, make a link
          FIND REGEX '([:space:]*methods[:space:]*)(.*)' IN wacontent
                                                         IGNORING CASE
                                                         SUBMATCHES head hyperlinkname.

          IF sy-subrc = 0.
            SHIFT hyperlinkname LEFT DELETING LEADING space.
            CONCATENATE methoddirectory
                        '/'
                        hyperlinkname
                        '.html'
                        INTO lowercaselink.

            TRANSLATE lowercaselink TO LOWER CASE.
            CONCATENATE head
                        ' <a href="'
                        lowercaselink
                        '">'
                        hyperlinkname
                        '</a>'
                        INTO wacontent.
            SHIFT wacontent RIGHT BY 2 PLACES.
          ENDIF.

*          Dictionary structures
          IF NOT getDictStructures IS INITIAL.
            FIND 'class' IN waContent IGNORING CASE.
            IF sy-subrc <> 0.
*              Hyperlink for dictionary/structure include
              copyLineLength = strlen( waContent ).
              copyOfCurrentLine = waContent.
              SPLIT copyOfCurrentLine AT space INTO head tail.
              SHIFT tail LEFT DELETING LEADING space.
              SPLIT tail AT space INTO head tail.

              TRY.
                  IF tail+0(1) = 'Y' OR tail+0(1) = 'Z' OR tail+0(1) = 'y' OR tail+0(1) = 'z' OR tail CS customerNameRange.
                    CLEAR waContent.
                    SHIFT tail LEFT DELETING LEADING space.
                    SPLIT tail AT period INTO hyperlinkName tail.
                    copyOfCurrentLine = 'include structure <a href ='.

                    lowercaseLink = hyperlinkName.
                    TRANSLATE lowercaseLink TO LOWER CASE.
*                  If we are running on a non UNIX environment we will need to remove forward slashes
                    IF frontendOpSystem = non_unix.
                      TRANSLATE lowercaseLink USING '/_'.
                    ENDIF.

                    CONCATENATE copyOfCurrentLine
                                '"'
                                lowercaseLink    "hyperlinkName
                                '/'
                                'dictionary-'
                                lowercaseLink    "hyperlinkName
                                period htmlExtension
                                '">'
                                hyperlinkName
                                '</a>'
                                period tail INTO copyOfCurrentLine.

*                  Pad the string back out with spaces
                    WHILE copyLineLength < currentLineLength.
                      SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                      copyLineLength = copyLineLength + 1.
                    ENDWHILE.
                    waContent = copyOfCurrentLine.
                  ENDIF.
                CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
              ENDTRY.
            ENDIF.
          ENDIF.

          htmlTable = waContent.

          TRY.
              IF htmlTable+0(1) = ` `.
                WHILE htmlTable CS ` `.
                  REPLACE ` ` WITH '&nbsp;' INTO htmlTable.
                  IF sy-subrc <> 0.
                    EXIT.
                  ENDIF.
                ENDWHILE.
              ENDIF.
            CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
          ENDTRY.
        ELSE.
          htmlTable = ''.
        ENDIF.
      ENDIF.
    ELSE.
      htmlTable = ''.
    ENDIF.

    CONCATENATE htmlTable '<br />' INTO htmlTable.
    APPEND htmlTable.
  ENDLOOP.

  APPEND `            </div>` TO htmlTable.
  APPEND `          </td>`  TO htmlTable.
  APPEND `        </tr>` TO htmlTable.
  APPEND `      </table>` TO htmlTable.
  APPEND `      </td>` TO htmlTable.
  APPEND `      </tr>` TO htmlTable.

* Add a html footer to the table
  PERFORM addHtmlFooter USING htmlTable[].

  iContents[] = htmlTable[].
ENDFORM.                                                                                            "convertClassToHtml

*----------------------------------------------------------------------------------------------------------------------
*  convertFunctionToHtml... Builds an HTML table based upon a text table.
*----------------------------------------------------------------------------------------------------------------------
FORM convertFunctionToHtml USING iContents LIKE dumIHtml[]
                                 VALUE(functionName)
                                 VALUE(ShortDescription)
                                 VALUE(sourceCodeType)
                                 VALUE(functionDocumentationExists)
                                 VALUE(isMainFunctionInclude)
                                 VALUE(htmlExtension)
                                 VALUE(customerNameRange)
                                 VALUE(getIncludes)
                                 VALUE(getDictStructures)
                                 VALUE(addBackground) TYPE abap_bool.

  DATA: htmlTable TYPE STANDARD TABLE OF string WITH HEADER LINE.
  DATA: head(255).
  DATA: tail(255).
  DATA: myTabix TYPE syTabix.
  DATA: nextLine TYPE syTabix.
  DATA: hyperlinkName TYPE string.
  DATA: copyOfCurrentLine TYPE string.
  DATA: currentLineLength TYPE i VALUE 0.
  DATA: copyLineLength TYPE i VALUE 0.
  DATA: ignoreFutureLines TYPE abap_bool VALUE false.
  DATA: foundAsterix TYPE abap_bool VALUE false.
  DATA: lowercaseLink TYPE string.
  DATA: waNextLine TYPE string.
  DATA: waContent TYPE string.
  DATA: inCommentMode TYPE abap_bool VALUE 'X'.

* Add a html header to the table
  PERFORM addHTMLHeader USING htmlTable[]
                              functionName
                              addBackground
                              ss_code.

  APPEND '<body>' TO htmlTable.
* Class name and description
  APPEND '<table class="outerTable">' TO htmlTable.
  APPEND `  <tr class="normalBoldLarge">` TO htmlTable.

  CONCATENATE `     <td><h2>Code listing for function ` functionName `</h2>` INTO htmlTable.
  APPEND htmlTable.

  CONCATENATE `<h3> Description: ` ShortDescription `</h3></td>` INTO htmlTable.
  APPEND htmlTable.
  APPEND `   </tr>` TO htmlTable.

* Code
  APPEND `  <tr>` TO htmlTable.
  APPEND `     <td>` TO htmlTable.

* Table containing code
  APPEND `     <table class="innerTable">` TO htmlTable.
  APPEND `       <tr>` TO htmlTable.
  APPEND `          <td>` TO htmlTable.

  LOOP AT iContents INTO waContent.
    myTabix = sy-tabix.

*   Extra code for adding global and doc hyperlinks to functions
    IF sourceCodeType = is_function AND isMainFunctionInclude = true.
      IF NOT ( waContent IS INITIAL ).
        IF sy-tabix > 1.
          IF waContent+0(1) = asterix AND ignoreFutureLines = false.
            foundAsterix = true.
          ELSE.
            IF foundAsterix = true.
*             Lets add our extra HTML lines in here
              APPEND '' TO HtmlTable.

*             Global data hyperlink
              copyOfcurrentLine = '<div class="codeComment">*       <a href ="' .
              lowercaseLink = functionName.
              TRANSLATE lowercaseLink TO LOWER CASE.
*             If we are running on a non UNIX environment we will need to remove forward slashes
              IF frontendOpSystem = non_unix.
                TRANSLATE lowercaseLink USING '/_'.
              ENDIF.

              CONCATENATE copyOfCurrentLine 'global-' lowercaseLink  "functionName
                          period htmlExtension '">' 'Global data declarations' '</a>' INTO copyOfCurrentLine.

              CONCATENATE copyOfCurrentLine '</div><br />' INTO copyOfCurrentLine.

              APPEND copyOfCurrentLine TO HtmlTable.

*             Documentation hyperlink.
              IF functionDocumentationExists = true.
                copyOfcurrentLine = '<div class="codeComment">*       <a href ="'.

                lowercaseLink = functionName.
                TRANSLATE lowercaseLink TO LOWER CASE.
*               If we are running on a non UNIX environment we will need to remove forward slashes
                IF frontendOpSystem = non_unix.
                  TRANSLATE lowercaseLink USING '/_'.
                ENDIF.

                CONCATENATE copyOfCurrentLine
                            'docs-'
                            lowercaseLink  "functionName
                            period htmlExtension '">'
                            'Function module documentation'
                            '</a>'
                            INTO copyOfCurrentLine.

                CONCATENATE copyOfCurrentLine '</div><br />' INTO copyOfCurrentLine.
                APPEND copyOfCurrentLine TO HtmlTable.
              ENDIF.

              foundAsterix = false.
              ignoreFutureLines = true.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

*   Carry on as normal
    IF NOT ( waContent IS INITIAL ).
      WHILE ( waContent CS '<' OR waContent CS '>' ).
        REPLACE '<' IN waContent WITH lt.
        REPLACE '>' IN waContent WITH gt.
      ENDWHILE.

      IF waContent+0(1) <> asterix.
        IF myTabix = 1.
          APPEND `   <div class="code">` TO htmlTable.
          incommentMode = false.
        ELSE.
          IF inCommentMode = true.
            APPEND `   </div>` TO htmlTable.
            inCommentMode = false.
            APPEND `   <div class="code">` TO htmlTable.
          ENDIF.
        ENDIF.

        currentLineLength = strlen( waContent ).

*       Don't hyperlink anything for files of type documentation
        IF sourceCodeType <> is_documentation.
*       Check for any functions to highlight
          IF ( waContent CS callfunction ) AND ( waContent <> 'DESTINATION' ).
            nextLine = myTabix + 1.
            READ TABLE iContents INTO waNextLine INDEX nextLine.
            TRANSLATE waNextLine TO UPPER CASE.
            IF waNextLine NS 'DESTINATION'.
              copyOfCurrentLine = waContent.
              SHIFT copyOfCurrentLine LEFT DELETING LEADING space.

              copyLineLength = strlen( copyofCurrentLine ).

              SPLIT copyOfCurrentLine AT space INTO head tail.
              SPLIT tail AT space INTO head tail.
              SPLIT tail AT space INTO head tail.
*             Function name is now in head
              TRANSLATE head USING ''' '.
              SHIFT head LEFT DELETING LEADING space.

              TRY.
                  IF head+0(1) = 'Y' OR head+0(1) = 'Z' OR head+0(1) = 'y' OR head+0(1) = 'z' OR head CS customerNameRange.

*                 Definately a customer function module
                    hyperLinkName = head.

                    IF sourceCodeType = is_function.
                      copyOfCurrentLine = 'call function <a href ="../'.
                    ELSE.
                      copyOfCurrentLine = 'call function <a href ="'.
                    ENDIF.

                    lowercaseLink = hyperlinkName.
                    TRANSLATE lowercaseLink TO LOWER CASE.
*                 If we are running on a non UNIX environment we will need to remove forward slashes
                    IF frontendOpSystem = non_unix.
                      TRANSLATE lowercaseLink USING '/_'.
                    ENDIF.

                    CONCATENATE copyOfCurrentLine
                                lowercaseLink     "hyperlinkName
                                '/'
                                lowercaseLink     "hyperlinkName
                                Period htmlExtension '">'
                                ''''
                                hyperlinkName
                                ''''
                                '</a>'
                                tail INTO copyOfCurrentLine.

*                 Pad the string back out with spaces
                    WHILE copyLineLength < currentLineLength.
                      SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                      copyLineLength = copyLineLength + 1.
                    ENDWHILE.

                    waContent = copyOfCurrentLine.
                  ENDIF.
                CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
              ENDTRY.
            ENDIF.
          ENDIF.
        ENDIF.

*       Check for any customer includes to hyperlink
        IF waContent CS include OR waContent CS lowinclude.
          copyOfCurrentLine = waContent.

          SHIFT copyOfCurrentLine LEFT DELETING LEADING space.
          copyLineLength = strlen( copyOfCurrentLine ).

          SPLIT copyOfCurrentLine AT space INTO head tail.
          SHIFT tail LEFT DELETING LEADING space.

          TRY.
              IF ( tail+0(1) = 'Y' OR tail+0(1) = 'Z' OR tail+0(1) = 'y' OR tail+0(1) = 'z'
                   OR tail CS customerNameRange OR tail+0(2) = 'mz' OR tail+0(2) = 'MZ' ) AND NOT getIncludes IS INITIAL.

*             Hyperlink for program includes
                CLEAR waContent.
                SHIFT tail LEFT DELETING LEADING space.
                SPLIT tail AT period INTO hyperlinkName tail.
                copyOfCurrentLine = 'include <a href ="'.

                lowercaseLink = hyperlinkName.
                TRANSLATE lowercaseLink TO LOWER CASE.
*             If we are running on a non UNIX environment we will need to remove forward slashes
                IF frontendOpSystem = non_unix.
                  TRANSLATE lowercaseLink USING '/_'.
                ENDIF.

                CONCATENATE copyOfCurrentLine
                            lowercaseLink       "hyperlinkName
                            period htmlExtension '">'
                            hyperlinkName
                            '</a>'
                            period tail INTO copyOfCurrentLine.

*             Pad the string back out with spaces
                WHILE copyLineLength < currentLineLength.
                  SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                  copyLineLength = copyLineLength + 1.
                ENDWHILE.
                waContent = copyOfCurrentLine.
              ELSE.
                IF NOT getDictStructures IS INITIAL.
*               Hyperlink for structure include
                  copyLineLength = strlen( copyofCurrentLine ).
                  SPLIT copyOfCurrentLine AT space INTO head tail.
                  SHIFT tail LEFT DELETING LEADING space.
                  SPLIT tail AT space INTO head tail.

                  TRY.
                      IF tail+0(1) = 'Y' OR tail+0(1) = 'Z' OR tail+0(1) = 'y' OR tail+0(1) = 'z' OR tail CS customerNameRange.
                        CLEAR waContent.
                        SHIFT tail LEFT DELETING LEADING space.
                        SPLIT tail AT period INTO hyperlinkName tail.
                        copyOfCurrentLine = 'include structure <a href ='.

                        lowercaseLink = hyperlinkName.
                        TRANSLATE lowercaseLink TO LOWER CASE.
*                   If we are running on a non UNIX environment we will need to remove forward slashes
                        IF frontendOpSystem = non_unix.
                          TRANSLATE lowercaseLink USING '/_'.
                        ENDIF.

                        CONCATENATE copyOfCurrentLine
                                    '"'
                                    lowercaseLink    "hyperlinkName
                                    '/'
                                    'dictionary-'
                                    lowercaseLink    "hyperlinkName
                                    period htmlExtension
                                    '">'
                                    hyperlinkName
                                    '</a>'
                                    period tail INTO copyOfCurrentLine.

*                   Pad the string back out with spaces
                        WHILE copyLineLength < currentLineLength.
                          SHIFT copyOfCurrentLine RIGHT BY 1 PLACES.
                          copyLineLength = copyLineLength + 1.
                        ENDWHILE.
                        waContent = copyOfCurrentLine.
                      ENDIF.
                    CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
                  ENDTRY.
                ENDIF.
              ENDIF.
            CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
          ENDTRY.
        ENDIF.
      ELSE.
        IF waContent+0(1) = asterix.
          IF myTabix = 1.
            APPEND `   <div class="codeComment">` TO htmlTable.
            inCommentMode = true.
          ELSE.
            IF inCommentMode = false.
              APPEND `   </div>` TO htmlTable.
              APPEND `   <div class="codeComment">` TO htmlTable.
              inCommentMode = true.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      htmlTable = waContent.

      TRY.
          IF htmlTable+0(1) = ` `.
            WHILE htmlTable CS ` `.
              REPLACE ` ` WITH '&nbsp;' INTO htmlTable.
              IF sy-subrc <> 0.
                EXIT.
              ENDIF.
            ENDWHILE.
          ENDIF.
        CATCH cx_sy_range_out_of_bounds INTO objRuntimeError.
      ENDTRY.

    ELSE.
      htmlTable = ''.
    ENDIF.
    CONCATENATE htmlTable '<br />' INTO htmlTable.
    APPEND htmlTable.
  ENDLOOP.

  APPEND `            </div>` TO htmlTable.
  APPEND `          </td>`  TO htmlTable.
  APPEND `        </tr>` TO htmlTable.
  APPEND `      </table>` TO htmlTable.
  APPEND `      </td>` TO htmlTable.
  APPEND `      </tr>` TO htmlTable.

* Add a html footer to the table
  PERFORM addHtmlFooter USING htmlTable[].

  iContents[] = htmlTable[].
ENDFORM.                                                                                         "convertFunctionToHtml

*----------------------------------------------------------------------------------------------------------------------
*  buildColumnHeaders... build table column names
*----------------------------------------------------------------------------------------------------------------------
FORM buildColumnHeaders USING iLocColumnCaptions LIKE dumiHtml[].

  APPEND 'Row' TO iLocColumnCaptions.
  APPEND 'Field name' TO iLocColumnCaptions.
  APPEND 'Position' TO iLocColumnCaptions.
  APPEND 'Key' TO iLocColumnCaptions.
  APPEND 'Data element' TO iLocColumnCaptions.
  APPEND 'Domain' TO iLocColumnCaptions.
  APPEND 'Datatype' TO iLocColumnCaptions.
  APPEND 'Length' TO iLocColumnCaptions.
  APPEND 'Lowercase' TO iLocColumnCaptions.
  APPEND 'Domain text' TO iLocColumnCaptions.
ENDFORM.                                                                                            "buildColumnHeaders

*----------------------------------------------------------------------------------------------------------------------
* addHTMLHeader...  add a html formatted header to our output table
*----------------------------------------------------------------------------------------------------------------------
FORM addHTMLHeader USING iLocHeader LIKE dumiHtml[]
                         VALUE(title)
                         VALUE(addBackground) TYPE abap_bool
                         VALUE(stylesheetType) TYPE char1.

  DATA: waHeader TYPE string.

  APPEND '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">' TO iLocHeader.
  APPEND '<html xmlns="http://www.w3.org/1999/xhtml">' TO iLocHeader.
  APPEND '<head>' TO iLocHeader.
*     append '<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />' to iLocHeader.
*  APPEND '<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=EUC-KR" />' TO iLocHeader.
  APPEND '<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />' TO iLocHeader.

  CONCATENATE '<title>' title '</title>' INTO waHeader.
  APPEND waHeader TO ilocHeader.

  CASE stylesheetType.
    WHEN ss_code.
      PERFORM addCodeStyles USING iLocHeader
                                  addBackground.
    WHEN ss_table.
      PERFORM addTableStyles USING iLocHeader
                                   addBackground.
  ENDCASE.

  PERFORM addGenericStyles USING iLocHeader
                                 addBackground.

  APPEND '</head>' TO iLocHeader.
ENDFORM.                                                                                                 "addHTMLHeader

*----------------------------------------------------------------------------------------------------------------------
* addCodeStyles... Add the stylesheets needed for HTML output
*----------------------------------------------------------------------------------------------------------------------
FORM addCodeStyles USING iLocHeader LIKE dumiHtml[]
                         VALUE(addBackground) TYPE abap_bool.

  APPEND '<style type="text/css">' TO iLocHeader.
  APPEND `.code{ font-family:"Courier New", Courier, monospace; color:#000; font-size:14px; background-color:#F2F4F7 }` TO iLocHeader.
  APPEND `  .codeComment {font-family:"Courier New", Courier, monospace; color:#0000F0; font-size:14px; background-color:#F2F4F7 }` TO iLocHeader.
  APPEND `  .normalBold{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:12px; font-weight:800 }` TO iLocHeader.
  APPEND `  .normalBoldLarge{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:16px; font-weight:800 }` TO iLocHeader.
  APPEND '</style>' TO iLocHeader.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
* addTableStyles... Add the stylesheets needed for HTML output
*----------------------------------------------------------------------------------------------------------------------
FORM addTableStyles USING iLocHeader LIKE dumiHtml[]
                          VALUE(addBackground) TYPE abap_bool.

  APPEND '<style type="text/css">' TO iLocHeader.
  APPEND `  th{text-align:left}` TO iLocHeader.

  APPEND `  .cell{` TO iLocHeader.
  APPEND `     font-family:"Courier New", Courier, monospace;` TO iLocHeader.
  APPEND `     color:#000;` TO iLocHeader.
  APPEND `     font-size:12px;` TO iLocHeader.
  APPEND `     background-color:#F2F4F7;` TO iLocHeader.
  APPEND `  }` TO iLocHeader.

  APPEND `  .cell td { border: thin solid #ccc; }` TO iLocHeader.
  APPEND `</style>` TO iLocHeader.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
* addTableStyles... Add the stylesheets needed for HTML output
*----------------------------------------------------------------------------------------------------------------------
FORM addGenericStyles USING iLocHeader LIKE dumiHtml[]
                          VALUE(addBackground) TYPE abap_bool.

  APPEND '<style type="text/css">' TO iLocHeader.

  APPEND `  .normal{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:12px }` TO iLocHeader.
  APPEND `  .footer{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:12px; text-align: center }` TO iLocHeader.
  APPEND `  h2{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:16px; font-weight:800 }` TO iLocHeader.
  APPEND `  h3{ font-family:Arial, Helvetica, sans-serif; color:#000; font-size:14px; font-weight:800 }` TO iLocHeader.

  APPEND `  .outerTable{` TO iLocHeader.
  IF NOT addBackground IS INITIAL.
    APPEND `   background-color:#E0E7ED;` TO iLocHeader.
  ENDIF.
  APPEND `   width:100%;` TO iLocHeader.
  APPEND `   border-top-width: thin;` TO iLocHeader.
  APPEND `   border-right-width: thin;` TO iLocHeader.
  APPEND `   border-right-width: thin;` TO iLocHeader.
  APPEND `   border-left-width: thin;` TO iLocHeader.
  APPEND `   border-top-style: solid;` TO iLocHeader.
  APPEND `   border-right-style: solid;` TO iLocHeader.
  APPEND `   border-bottom-style: solid;` TO iLocHeader.
  APPEND `   border-left-style: solid;` TO iLocHeader.
  APPEND `  }` TO iLocHeader.

  APPEND `  .innerTable{` TO iLocHeader.
  IF NOT addBackground IS INITIAL.
    APPEND `   background-color:#F2F4F7;` TO iLocHeader.
  ENDIF.
  APPEND `   width:100%;` TO iLocHeader.
  APPEND `   border-top-width: thin;` TO iLocHeader.
  APPEND `   border-right-width: thin;` TO iLocHeader.
  APPEND `   border-bottom-width: thin;` TO iLocHeader.
  APPEND `   border-left-width: thin;` TO iLocHeader.
  APPEND `   border-top-style: solid;` TO iLocHeader.
  APPEND `   border-right-style: solid;` TO iLocHeader.
  APPEND `   border-bottom-style: solid;` TO iLocHeader.
  APPEND `   border-left-style: solid;` TO iLocHeader.
  APPEND `  }` TO iLocHeader.
  APPEND '</style>' TO iLocHeader.
ENDFORM.

*----------------------------------------------------------------------------------------------------------------------
* addHTMLFooter...  add a html formatted footer to our output table
*----------------------------------------------------------------------------------------------------------------------
FORM addHTMLFooter USING iLocFooter LIKE dumiHtml[].

  DATA: footerMessage TYPE string.
  DATA: waFooter TYPE string.

  PERFORM buildFooterMessage USING footerMessage.

  APPEND `   <tr>` TO iLocFooter.
  CONCATENATE '<td class="footer">' footerMessage '</td>' INTO waFooter.
  APPEND waFooter TO iLocFooter.
  APPEND `   </tr>` TO iLocFooter.
  APPEND `</table>` TO iLocFooter.
  APPEND '</body>' TO iLocFooter.
  APPEND '</html>' TO iLocFooter.
ENDFORM.                                                                                                 "addHTMLFooter

*----------------------------------------------------------------------------------------------------------------------
* buildFooterMessage...Returns a footer message based on the output file type.
*----------------------------------------------------------------------------------------------------------------------
FORM buildFooterMessage USING returnMessage.

  CONCATENATE `Extracted by Mass Download version `
              versionno ` - E.G.Mellodew. 1998-`
              sy-datum+0(4) `. Sap Release ` sy-saprl INTO returnMessage.
ENDFORM.                                                                                            "buildFooterMessage

***********************************************************************************************************************
********************************************DISPLAY ROUTINES***********************************************************
***********************************************************************************************************************

*----------------------------------------------------------------------------------------------------------------------
*  fillTreeNodeTables...
*----------------------------------------------------------------------------------------------------------------------
FORM fillTreeNodeTables USING iLocDictionary LIKE iDictionary[]
                              iLocTreeDisplay LIKE iTreeDisplay[]
                              VALUE(runTime).

  DATA: tableLines TYPE i.
  DATA: waTreeDisplay LIKE sNodeText.
  FIELD-SYMBOLS: <waDictionary> TYPE tDictTable.
  DATA: tableLinesString TYPE string.
  DATA: runtimeChar(10).
  DATA: subLevel TYPE string.

  tableLines = lines( iLocDictionary ).
  tableLinesString = tableLines.

  IF tableLines = 1.
    CONCATENATE tableLinesString 'table downloaded' INTO waTreeDisplay-text2 SEPARATED BY space.
  ELSE.
    CONCATENATE tableLinesString 'tables downloaded' INTO waTreeDisplay-text2 SEPARATED BY space.
  ENDIF.

  WRITE runTime TO runtimeChar.
  CONCATENATE waTreeDisplay-text2 '- runtime' runTimeChar INTO waTreeDisplay-text2 SEPARATED BY space.

* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  APPEND waTreeDisplay TO iLocTreeDisplay.

  LOOP AT iLocDictionary ASSIGNING <waDictionary>.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waDictionary>-tablename.
    waTreeDisplay-tcolor2    = 3.
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 3.
    waTreeDisplay-tpos3      = 60.
    CONCATENATE 'Dictionary:' <waDictionary>-tableTitle INTO waTreeDisplay-text3 SEPARATED BY space.

    APPEND waTreeDisplay TO iLocTreeDisplay.
  ENDLOOP.
ENDFORM.                                                                                            "fillTreeNodeTables

*----------------------------------------------------------------------------------------------------------------------
*  fillTreeNodeMessages...
*----------------------------------------------------------------------------------------------------------------------
FORM fillTreeNodeMessages USING iLocMessages LIKE iMessages[]
                                iLocTreeDisplay LIKE iTreeDisplay[]
                                VALUE(runTime).

  DATA: tableLines TYPE i.
  DATA: waTreeDisplay LIKE sNodeText.
  FIELD-SYMBOLS: <waMessage> TYPE tMessage.
  DATA: tableLinesString TYPE string.
  DATA: runtimeChar(10).

  SORT iLocMessages ASCENDING BY arbgb.

  LOOP AT iLocMessages ASSIGNING <waMessage>.
    AT NEW arbgb.
      tableLines = tableLines + 1.
    ENDAT.
  ENDLOOP.
  tableLinesString = tableLines.

  IF tableLines = 1.
    CONCATENATE tableLinesString 'message class downloaded' INTO waTreeDisplay-text2 SEPARATED BY space.
  ELSE.
    CONCATENATE tableLinesString 'message classes downloaded' INTO waTreeDisplay-text2 SEPARATED BY space.
  ENDIF.

  WRITE runTime TO runTimeChar.
  CONCATENATE waTreeDisplay-text2 '- runtime' runTimeChar INTO waTreeDisplay-text2 SEPARATED BY space.

* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2 = 60.
  waTreeDisplay-tcolor2 = 1.
  APPEND waTreeDisplay TO iLocTreeDisplay.

  LOOP AT iLocMessages ASSIGNING <waMessage>.
    AT NEW arbgb.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waMessage>-arbgb.
      waTreeDisplay-tcolor2    = 5.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 5.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = <waMessage>-sText.
      CONCATENATE 'Message class:'  waTreeDisplay-text3 INTO waTreeDisplay-text3 SEPARATED BY space.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDAT.
  ENDLOOP.
ENDFORM.                                                                                          "fillTreeNodeMessages

*----------------------------------------------------------------------------------------------------------------------
*  fillTreeNodeFunctions...
*----------------------------------------------------------------------------------------------------------------------
FORM fillTreeNodeFunctions USING iLocFunctions LIKE iFunctions[]
                                 iLocTreeDisplay LIKE iTreeDisplay[]
                                 VALUE(runTime).

  DATA: tableLines TYPE i.
  DATA: waTreeDisplay LIKE sNodeText.
  FIELD-SYMBOLS: <waFunction> TYPE tFunction.
  FIELD-SYMBOLS: <waScreen> TYPE tScreenFlow.
  FIELD-SYMBOLS: <waGUITitle> TYPE tGUITitle.
  FIELD-SYMBOLS: <waDictionary> TYPE tDictTable.
  FIELD-SYMBOLS: <waInclude> TYPE tInclude.
  FIELD-SYMBOLS: <waMessage> TYPE tMessage.
  DATA: tableLinesString TYPE string.
  DATA: runtimeChar(10).

  SORT iLocFunctions ASCENDING BY functionName.

  tableLines = lines( iLocFunctions ).
  tableLinesString = tableLines.

  IF tableLines = 1.
    CONCATENATE tableLinesString ` function downloaded` INTO waTreeDisplay-text2.
  ELSE.
    CONCATENATE tableLinesString ` functions downloaded` INTO waTreeDisplay-text2.
  ENDIF.

  WRITE runTime TO runTimeChar.

  CONCATENATE waTreeDisplay-text2 ` - runtime ` runTimeChar INTO waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  APPEND waTreeDisplay TO iLocTreeDisplay.

* Lets fill the detail in
  LOOP AT iLocFunctions ASSIGNING <wafunction>.
    waTreeDisplay-tlevel = 2.
    waTreeDisplay-text2 = <wafunction>-functionName.
    waTreeDisplay-tcolor2    = 7.
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 7.
    waTreeDisplay-tpos3      = 60.
    CONCATENATE `Function: ` <wafunction>-functionName INTO waTreeDisplay-text3.
    APPEND waTreeDisplay TO iLocTreeDisplay.

*   Screens.
    LOOP AT <waFunction>-iScreenFlow ASSIGNING <waScreen>.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waScreen>-screen.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'Screen'.
      APPEND waTreeDisplay TO iTreeDisplay.
    ENDLOOP.

*   GUI Title.
    LOOP AT <waFunction>-iGUITitle ASSIGNING <waGUITitle>.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waGUITitle>-obj_code.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'GUI Title'.
      APPEND waTreeDisplay TO iTreeDisplay.
    ENDLOOP.

*   Fill in the tree with include information
    LOOP AT <waFunction>-iIncludes ASSIGNING <waInclude>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waInclude>-includeName.
      waTreeDisplay-tcolor2    = 4.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 4.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Include:   ` <waInclude>-includeTitle INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.

*   fill in the tree with dictionary information
    LOOP AT <waFunction>-iDictStruct ASSIGNING <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Dictionary:` <waDictionary>-tableTitle INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.

*   fill in the tree with message information
    SORT <waFunction>-iMessages[] ASCENDING BY arbgb.
    LOOP AT <waFunction>-iMessages ASSIGNING <waMessage>.
      AT NEW arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        IF <waMessage>-sText IS INITIAL.
          SELECT SINGLE stext FROM t100a
                              INTO <waMessage>-stext
                              WHERE arbgb = <waMessage>-arbgb.
        ENDIF.

        waTreeDisplay-text3 = <waMessage>-sText.
        CONCATENATE `Message class: `  waTreeDisplay-text3 INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDAT.
    ENDLOOP.
  ENDLOOP.
ENDFORM.                                                                                         "fillTreeNodeFunctions

*----------------------------------------------------------------------------------------------------------------------
*  fillTreeNodePrograms
*----------------------------------------------------------------------------------------------------------------------
FORM fillTreeNodePrograms USING iLocPrograms LIKE iPrograms[]
                                iLocFunctions LIKE iFunctions[]
                                iLocTreeDisplay LIKE iTreeDisplay[]
                                VALUE(runTime).

  DATA: tableLines TYPE i.
  DATA: waTreeDisplay LIKE sNodeText.
  FIELD-SYMBOLS: <waProgram> TYPE tProgram.
  FIELD-SYMBOLS: <waScreen> TYPE tScreenFlow.
  FIELD-SYMBOLS: <waFunction> TYPE tFunction.
  FIELD-SYMBOLS: <waDictionary> TYPE tDictTable.
  FIELD-SYMBOLS: <waInclude> TYPE tInclude.
  FIELD-SYMBOLS: <waMessage> TYPE tMessage.
  DATA: tableLinesString TYPE string.
  DATA: runtimeChar(10).

  tableLines = lines( iLocPrograms ).
  tableLinesString = tableLines.

  IF tableLines = 1.
    CONCATENATE tableLinesString ` program downloaded` INTO waTreeDisplay-text2.
  ELSE.
    CONCATENATE tableLinesString ` programs downloaded` INTO waTreeDisplay-text2.
  ENDIF.

  WRITE runTime TO runTimeChar.

  CONCATENATE waTreeDisplay-text2 ` - runtime ` runTimeChar INTO waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  APPEND waTreeDisplay TO iTreeDisplay.

  LOOP AT iLocPrograms ASSIGNING <waProgram>.
*   Main programs.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waProgram>-progName.
    waTreeDisplay-tcolor2    = 1.
*   Description
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 1.
    waTreeDisplay-tpos3      = 60.
    CONCATENATE `Program: ` <waProgram>-programTitle INTO waTreeDisplay-text3.
    APPEND waTreeDisplay TO iTreeDisplay.
*   Screens.
    LOOP AT <waProgram>-iScreenFlow ASSIGNING <waScreen>.
      waTreeDisplay-tlevel = '3'.
      waTreeDisplay-text2 = <waScreen>-screen.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'Screen'.
      APPEND waTreeDisplay TO iTreeDisplay.
    ENDLOOP.
*   fill in the tree with message information
    SORT <waProgram>-iMessages[] ASCENDING BY arbgb.
    LOOP AT <waProgram>-iMessages ASSIGNING <waMessage>.
      AT NEW arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        IF <waMessage>-sText IS INITIAL.
          SELECT SINGLE stext FROM t100a
                              INTO <waMessage>-stext
                              WHERE arbgb = <waMessage>-arbgb.
        ENDIF.

        waTreeDisplay-text3 = <waMessage>-sText.
        CONCATENATE `Message class: `  waTreeDisplay-text3 INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDAT.
    ENDLOOP.
*   Fill in the tree with include information
    LOOP AT <waProgram>-iIncludes ASSIGNING <waInclude>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waInclude>-includeName.
      waTreeDisplay-tcolor2    = 4.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 4.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Include:   ` <waInclude>-includeTitle INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.
*   fill in the tree with dictionary information
    LOOP AT <waProgram>-iDictStruct ASSIGNING <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Dictionary:    ` <waDictionary>-tableTitle INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.

*   Function Modules
    LOOP AT iLocFunctions ASSIGNING <wafunction> WHERE programLinkName = <waProgram>-progname.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 = <wafunction>-functionName.
      waTreeDisplay-tcolor2    = 7.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 7.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Function:      ` <wafunction>-functionName INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.

*     Fill in the tree with include information
      LOOP AT <waFunction>-iIncludes ASSIGNING <waInclude>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waInclude>-includeName.
        waTreeDisplay-tcolor2    = 4.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 4.
        waTreeDisplay-tpos3      = 60.
        CONCATENATE `Include:       ` <waInclude>-includeTitle INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDLOOP.

*     fill in the tree with dictionary information
      LOOP AT <waFunction>-iDictStruct ASSIGNING <waDictionary>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waDictionary>-tablename.
        waTreeDisplay-tcolor2    = 3.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 3.
        waTreeDisplay-tpos3      = 60.
        CONCATENATE `Dictionary:    ` <wadictionary>-tableTitle INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDLOOP.

*     fill in the tree with message information
      SORT <waFunction>-iMessages[] ASCENDING BY arbgb.
      LOOP AT <waFunction>-iMessages ASSIGNING <waMessage>.
        AT NEW arbgb.
          waTreeDisplay-tlevel = 4.
          waTreeDisplay-text2 = <waMessage>-arbgb.
          waTreeDisplay-tcolor2    = 5.
          waTreeDisplay-tlength3   = 80.
          waTreeDisplay-tcolor3    = 5.
          waTreeDisplay-tpos3      = 60.

*         Select the message class text if we do not have it already
          IF <waMessage>-sText IS INITIAL.
            SELECT SINGLE stext FROM t100a
                                INTO <waMessage>-stext
                                WHERE arbgb = <waMessage>-arbgb.
          ENDIF.

          waTreeDisplay-text3 = <waMessage>-sText.
          CONCATENATE `Message class:  `  waTreeDisplay-text3 INTO waTreeDisplay-text3.
          APPEND waTreeDisplay TO iLocTreeDisplay.
        ENDAT.
      ENDLOOP.
    ENDLOOP.
  ENDLOOP.
ENDFORM.                                                                                          "fillTreeNodePrograms

*----------------------------------------------------------------------------------------------------------------------
*  fillTreeNodeClasses
*----------------------------------------------------------------------------------------------------------------------
FORM fillTreeNodeClasses USING iLocClasses LIKE iClasses[]
                               iLocFunctions LIKE iFunctions[]
                               iLocTreeDisplay LIKE iTreeDisplay[]
                               VALUE(runTime).

  DATA: tableLines TYPE i.
  DATA: waTreeDisplay LIKE sNodeText.
  FIELD-SYMBOLS: <waClass> TYPE tClass.
  FIELD-SYMBOLS: <waMethod> TYPE tMethod.
  FIELD-SYMBOLS: <waFunction> TYPE tFunction.
  FIELD-SYMBOLS: <waDictionary> TYPE tDictTable.
  FIELD-SYMBOLS: <waInclude> TYPE tInclude.
  FIELD-SYMBOLS: <waMessage> TYPE tMessage.
  DATA: tableLinesString TYPE string.
  DATA: runtimeChar(10).

  tableLines = lines( iLocClasses ).
  tableLinesString = tableLines.

  IF tableLines = 1.
    CONCATENATE tableLinesString ` class downloaded` INTO waTreeDisplay-text2.
  ELSE.
    CONCATENATE tableLinesString ` classes downloaded` INTO waTreeDisplay-text2.
  ENDIF.

  WRITE runTime TO runTimeChar.

  CONCATENATE waTreeDisplay-text2 ` - runtime ` runTimeChar INTO waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  APPEND waTreeDisplay TO iTreeDisplay.

  LOOP AT iLocClasses ASSIGNING <waClass>.
*   Main Class.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waClass>-clsName.
    waTreeDisplay-tcolor2    = 1.
*   Description
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 1.
    waTreeDisplay-tpos3      = 60.
    CONCATENATE `Class:    ` <waClass>-descript INTO waTreeDisplay-text3.
    APPEND waTreeDisplay TO iTreeDisplay.

*   fill in the tree with method information
    LOOP AT <waClass>-iMethods[] ASSIGNING <waMethod>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waMethod>-cmpname.
      waTreeDisplay-tcolor2    = 2.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 2.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Method:   ` <waMethod>-descript INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.

*   fill in the tree with message information
    SORT <waClass>-iMessages[] ASCENDING BY arbgb.
    LOOP AT <waClass>-iMessages ASSIGNING <waMessage>.
      AT NEW arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        IF <waMessage>-sText IS INITIAL.
          SELECT SINGLE stext FROM t100a
                              INTO <waMessage>-stext
                              WHERE arbgb = <waMessage>-arbgb.
        ENDIF.

        waTreeDisplay-text3 = <waMessage>-sText.
        CONCATENATE `Message class: `  waTreeDisplay-text3 INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDAT.
    ENDLOOP.

*   fill in the tree with dictionary information
    LOOP AT <waClass>-iDictStruct ASSIGNING <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Dictionary:    ` <waDictionary>-tableTitle INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.
    ENDLOOP.

*   Function Modules
    LOOP AT iLocFunctions ASSIGNING <wafunction> WHERE programLinkName = <waClass>-clsname.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 = <wafunction>-functionName.
      waTreeDisplay-tcolor2    = 7.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 7.
      waTreeDisplay-tpos3      = 60.
      CONCATENATE `Function:      ` <wafunction>-functionName INTO waTreeDisplay-text3.
      APPEND waTreeDisplay TO iLocTreeDisplay.

*     Fill in the tree with include information
      LOOP AT <waFunction>-iIncludes ASSIGNING <waInclude>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waInclude>-includeName.
        waTreeDisplay-tcolor2    = 4.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 4.
        waTreeDisplay-tpos3      = 60.
        CONCATENATE `Include:       ` <waInclude>-includeTitle INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDLOOP.

*     fill in the tree with dictionary information
      LOOP AT <waFunction>-iDictStruct ASSIGNING <waDictionary>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waDictionary>-tablename.
        waTreeDisplay-tcolor2    = 3.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 3.
        waTreeDisplay-tpos3      = 60.
        CONCATENATE `Dictionary:    ` <wadictionary>-tableTitle INTO waTreeDisplay-text3.
        APPEND waTreeDisplay TO iLocTreeDisplay.
      ENDLOOP.

*     fill in the tree with message information
      SORT <waFunction>-iMessages[] ASCENDING BY arbgb.
      LOOP AT <waFunction>-iMessages ASSIGNING <waMessage>.
        AT NEW arbgb.
          waTreeDisplay-tlevel = 4.
          waTreeDisplay-text2 = <waMessage>-arbgb.
          waTreeDisplay-tcolor2    = 5.
          waTreeDisplay-tlength3   = 80.
          waTreeDisplay-tcolor3    = 5.
          waTreeDisplay-tpos3      = 60.

*         Select the message class text if we do not have it already
          IF <waMessage>-sText IS INITIAL.
            SELECT SINGLE stext FROM t100a
                                INTO <waMessage>-stext
                                WHERE arbgb = <waMessage>-arbgb.
          ENDIF.

          waTreeDisplay-text3 = <waMessage>-sText.
          CONCATENATE `Message class:  `  waTreeDisplay-text3 INTO waTreeDisplay-text3.
          APPEND waTreeDisplay TO iLocTreeDisplay.
        ENDAT.
      ENDLOOP.
    ENDLOOP.
  ENDLOOP.
ENDFORM.                                                                                           "fillTreeNodeClasses

*----------------------------------------------------------------------------------------------------------------------
* displayTree...
*----------------------------------------------------------------------------------------------------------------------
FORM displayTree USING iLocTreeDisplay LIKE iTreeDisplay[].

  DATA: waTreeDisplay TYPE snodetext.

* build up the tree from the internal table node
  CALL FUNCTION 'RS_TREE_CONSTRUCT'
    TABLES
      nodetab            = iTreeDisplay
    EXCEPTIONS
      tree_failure       = 1
      id_not_found       = 2
      wrong_relationship = 3
      OTHERS             = 4.

* get the first index and expand the whole tree
  READ TABLE iLoctreeDisplay INTO waTreeDisplay INDEX 1.
  CALL FUNCTION 'RS_TREE_EXPAND'
    EXPORTING
      node_id   = waTreeDisplay-id
      all       = 'X'
    EXCEPTIONS
      not_found = 1
      OTHERS    = 2.

* now display the tree
  CALL FUNCTION 'RS_TREE_LIST_DISPLAY'
    EXPORTING
      callback_program      = sy-cprog
      callback_user_command = 'CB_USER_COMMAND'
      callback_text_display = 'CB_text_DISPLAY'
      callback_top_of_page  = 'TOP_OF_PAGE'
    EXCEPTIONS
      OTHERS                = 1.
ENDFORM.                                                                                                   "displayTree

*----------------------------------------------------------------------------------------------------------------------
*  topOfPage... for tree display routines.
*----------------------------------------------------------------------------------------------------------------------
FORM topOfPage.

ENDFORM.


*Messages
*----------------------------------------------------------
*
* Message class: OO
*000   & & & &

----------------------------------------------------------------------------------
Extracted by Mass Download version 1.4.6 - E.G.Mellodew. 1998-2024. Sap Release 754
